{% extends 'manage_orders/index.html' %}
{% load static %}
{% block content %}
<h5 class="mt-3">Create Order</h5>
<!-- Price Band Selector -->
<div class="mb-3" style="max-width:420px;">
    <label for="price-band" class="form-label fw-semibold">Select Price Band</label>
    <select id="price-band" class="form-select" style="height: 56px; font-size: 1.25rem;">
        {% for band, value in price_band.items %}
            <option value="{{ value }}">{{ band }}</option>
        {% endfor %}
    </select>
</div>
<!-- Categories below Price Band (horizontal scroll) -->
<div id="categories-section" class="mb-3">
  <div class="fw-semibold small text-uppercase text-secondary mb-2">Categories</div>
  <div id="category-strip" class="d-flex flex-nowrap overflow-auto gap-2 py-2" style="font-size:1.15rem; -webkit-overflow-scrolling: touch;"></div>
</div>

<!-- Main layout: Items (70%) | Basket (30%) -->
<div class="row" id="order-workspace">
  <div class="col-12 col-lg-9" id="items-pane" style="max-height:70vh; overflow:auto;">
    <div class="fw-semibold small text-uppercase text-secondary mb-2">Items</div>
    <div id="items-container" class="row g-3">
      <!-- Items injected via JS -->
    </div>
  </div>
  <div class="col-12 col-lg-3 border-start" id="basket-pane" style="max-height:70vh; overflow:auto;">
    <div class="fw-semibold small text-uppercase text-secondary mb-2">Basket</div>
    <ul class="list-group" id="basket-list" style="font-size:1.15rem;"></ul>
    <div class="mt-3 d-flex justify-content-between align-items-center">
      <span class="fw-semibold">Total</span>
      <span id="basket-total" class="fs-5">£0.00</span>
    </div>
    <div class="mt-4 text-end">
      <button class="btn btn-lg btn-outline-secondary px-4 py-2 me-2" id="clear-basket" disabled>Clear</button>
      <button class="btn btn-lg btn-primary px-4 py-2" id="checkout" disabled>Checkout</button>
    </div>
  </div>
</div>

<!-- Option selection modal -->
<div class="modal fade" id="optionModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered modal-dialog-scrollable modal-lg modal-fullscreen-sm-down">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="optionTitle">Choose an option</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <ul class="list-group" id="optionList"></ul>
      </div>
    </div>
  </div>
  </div>
<style>
    /* Touch-friendly tweaks */
  /* Horizontal category chips */
  #category-strip { scroll-snap-type: x mandatory; }
  .cat-chip { white-space: nowrap; scroll-snap-align: start; }
    #items-container .item-btn {
        min-height: 64px;
        font-size: 1.15rem;
        padding: 1rem 0.75rem;
        border-width: 2px;
        border-radius: 0.75rem;
    }
    #basket-list .list-group-item {
        min-height: 56px;
        font-size: 1.15rem;
        padding-top: 0.75rem;
        padding-bottom: 0.75rem;
    }
    #clear-basket, #checkout {
        font-size: 1.15rem;
        min-width: 120px;
        min-height: 48px;
    }
</style>

{% endblock %}
{% block extra_js %}
<script>
  // Load menu JSON client-side from static files
  const MENU_URL = '{% static "menu/local_menu.json" %}';
  let MENU = {};

  const categoryStrip = document.getElementById('category-strip');
  const priceBandSelect = document.getElementById('price-band');
  function slugify(name){
    return name.toLowerCase().replace(/\s+/g,'-').replace(/[()']/g,'');
  }

  function renderCategories(){
    categoryStrip.innerHTML = '';
    const names = Object.keys(MENU);
    if(!names.length){
      categoryStrip.innerHTML = '<span class="text-muted small">No categories</span>';
      return;
    }
    names.forEach(n => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'btn btn-outline-primary cat-chip px-3';
      btn.dataset.cat = slugify(n);
      btn.dataset.name = n;
      btn.innerHTML = `${n} <span class="badge bg-light text-dark ms-1">${(MENU[n]||[]).length}</span>`;
      categoryStrip.appendChild(btn);
    });
  }
  const itemsContainer = document.getElementById('items-container');
  const basketList = document.getElementById('basket-list');
  const clearBtn = document.getElementById('clear-basket');
  const checkoutBtn = document.getElementById('checkout');
  const basketTotalEl = document.getElementById('basket-total');
  const optionModalEl = document.getElementById('optionModal');
  let optionModal; // Bootstrap modal instance

  let basket = [];
  let currentPrices = {}; // { prod: { price, dc_price } }
  let currentCategory = null;
  // Extract all add_on_options_x sections present under custom_options_data
  // Returns { sections: [{ id, mode: 'addons'|'radio_free'|'radio_paid', title, required, optional, choices }], specialInstructions, toppingsNotWanted }
  function getAllOptionSections(item){
    const d = item.custom_options_data || {};
    const toppings = Array.isArray(d.toppings_not_wanted) ? d.toppings_not_wanted.filter(x => typeof x === 'string' && x.trim().length) : [];
    const list = [];
    const pairs = [
      { id: 'add_on_options_1', key: d.add_on_options_1 || d.add_on_option_1, mode: 'addons' },
      { id: 'add_on_options_2', key: d.add_on_options_2 || d.add_on_option_2, mode: 'radio_free' },
      { id: 'add_on_options_3', key: d.add_on_options_3 || d.add_on_option_3, mode: 'radio_paid' }
    ];
    pairs.forEach(p => {
      if (p.key && Array.isArray(p.key.choose)){
        const choices = p.key.choose.filter(ch => ch && (ch.PRODNUMB !== undefined));
        if (choices.length){
          list.push({ id: p.id, mode: p.mode, title: p.key.title || 'Choose', required: !!p.key.required, optional: !!p.key.optional, choices });
        }
      }
    });
    return { sections: list, specialInstructions: !!d.special_instructions, toppingsNotWanted: toppings };
  }


  // Return unified options description for an item
  // { mode: 'single'|'addons'|'radio_free'|null, title, choices: [{name, PRODNUMB}], required?: boolean, optional?: boolean, specialInstructions?: boolean }
  function getOptions(item){
    const d = item.custom_options_data || {};
    const toppings = Array.isArray(d.toppings_not_wanted) ? d.toppings_not_wanted.filter(x => typeof x === 'string' && x.trim().length) : [];
    // Single-select shape
    if (d.option_1 && Array.isArray(d.option_1.choose)) {
      const choices = d.option_1.choose.filter(ch => ch && ch.PRODNUMB);
      if (choices.length) return { mode: 'single', title: item.name, choices, specialInstructions: !!d.special_instructions, toppingsNotWanted: toppings };
    }
    // Radio single-select add-on, paid (choice price adds to base) — prioritize before add-ons
    const radioPaidKey = d.add_on_options_3 || d.add_on_option_3; // accept either key
    if (radioPaidKey && Array.isArray(radioPaidKey.choose)) {
      const choices = radioPaidKey.choose.filter(ch => ch && (ch.PRODNUMB !== undefined));
      if (choices.length) return {
        mode: 'radio_paid',
        title: radioPaidKey.title || 'Choose one',
        choices,
        required: !!radioPaidKey.required,
        optional: !!radioPaidKey.optional,
        free: String(radioPaidKey.type || '').toLowerCase().includes('free'), // likely false
        specialInstructions: (d.special_instructions !== undefined) ? !!d.special_instructions : !!radioPaidKey.special_instructions,
        toppingsNotWanted: toppings
      };
    }
    // Add-on multi-select shape
    const addKey = d.add_on_options_1 || d.add_on_option_1; // accept either key
    if (addKey && Array.isArray(addKey.choose)) {
      const choices = addKey.choose.filter(ch => ch && ch.PRODNUMB);
      if (choices.length) return {
        mode: 'addons',
        title: addKey.title || 'Choose add-ons',
        choices,
        required: !!addKey.required,
        optional: !!addKey.optional,
        // special_instructions now lives under custom_options_data; keep fallback for backward compat
        specialInstructions: (d.special_instructions !== undefined) ? !!d.special_instructions : !!addKey.special_instructions,
        toppingsNotWanted: toppings
      };
    }
    // Radio single-select add-on, free (doesn't affect price)
    const radioKey = d.add_on_options_2 || d.add_on_option_2; // accept either key
    if (radioKey && Array.isArray(radioKey.choose)) {
      const choices = radioKey.choose.filter(ch => ch && (ch.PRODNUMB !== undefined));
      if (choices.length) return {
        mode: 'radio_free',
        title: radioKey.title || 'Choose one',
        choices,
        required: !!radioKey.required,
        optional: !!radioKey.optional,
        free: String(radioKey.type || '').toLowerCase().includes('free'),
        specialInstructions: (d.special_instructions !== undefined) ? !!d.special_instructions : !!radioKey.special_instructions,
        toppingsNotWanted: toppings
      };
    }
    return { mode: null, title: item.name, choices: [] };
  }

  async function fetchPricesFor(catName){
    // Collect product IDs in this category
    const items = MENU[catName] || [];
    const ids = new Set();
    items.forEach(i => {
      if (i.PRODNUMB) ids.add(i.PRODNUMB);
      if (i.custom_options) {
        // Include choices from any single-option flow
        const opts = getOptions(i);
        (opts.choices||[]).forEach(ch => ids.add(ch.PRODNUMB));
        // Include all add_on_options_x choices
        const all = getAllOptionSections(i);
        all.sections.forEach(sec => sec.choices.forEach(ch => ids.add(ch.PRODNUMB)));
      }
    });
    const prodIds = [...ids];
    if (!prodIds.length) { currentPrices = {}; return; }
    const params = new URLSearchParams({ band: priceBandSelect.value, prods: prodIds.join(',') });
    const resp = await fetch(`/api/prices?${params.toString()}`);
    if (!resp.ok) { currentPrices = {}; return; }
    const data = await resp.json();
    currentPrices = data.prices || {};
  }

  function formatPence(p){
    const v = (Number(p)||0) / 100;
    return v.toLocaleString(undefined, { style:'currency', currency:'GBP' });
  }

  async function renderItems(catName) {
    itemsContainer.innerHTML = '';
    currentCategory = catName;
    const items = MENU[catName] || [];
    if(!items.length){
      itemsContainer.innerHTML = '<div class="text-muted small">No items</div>';
      return;
    }
    await fetchPricesFor(catName);
    items.forEach(item => {
      const col = document.createElement('div');
      col.className = 'col-6';
      const prod = item.PRODNUMB || '';
      let priceInfo = currentPrices[String(prod)] || { price: 0, dc_price: 0 };
      let priceText = '';
      let fromPrefix = '';
      let inlineBasePrice = '';
      if (item.custom_options) {
        // Compute min price among choices for modes that affect price
        const opts = getOptions(item);
        if (opts.mode !== 'radio_free') {
          let minP = Infinity;
          opts.choices.forEach(ch => {
            const info = currentPrices[String(ch.PRODNUMB)] || { price: 0 };
            if (info.price && info.price < minP) minP = info.price;
          });
          if (isFinite(minP)) {
            priceText = formatPence(minP);
            fromPrefix = 'from ';
          }
        }
        // If base_price is flagged and base has a price, show inline next to name (no prefix)
        if (item.base_price && priceInfo.price) {
          inlineBasePrice = formatPence(priceInfo.price);
        }
      } else {
        priceText = priceInfo.price ? formatPence(priceInfo.price) : '';
      }
      col.innerHTML = `
        <button class="btn btn-outline-secondary w-100 text-start btn-sm item-btn" data-name="${item.name}" data-prod="${prod}" data-price="${priceInfo.price}" data-cat="${catName}" data-custom="${item.custom_options ? '1':'0'}">
          <span class="d-block fw-semibold">
            <span>${item.name}</span>
            ${inlineBasePrice ? `<span class="text-secondary small ms-2">${inlineBasePrice}</span>` : ''}
          </span>
          ${item.custom_options ? '<span class="badge text-bg-warning">Options</span>' : ''}
          ${priceText ? `<span class=\"d-block text-secondary small\">${fromPrefix}${priceText}</span>` : ''}
        </button>`;
      itemsContainer.appendChild(col);
    });
  }

  function renderBasket(){
    basketList.innerHTML='';
    if(!basket.length){
      basketList.innerHTML = '<li class="list-group-item text-muted small">Empty</li>';
      clearBtn.disabled = true;
      checkoutBtn.disabled = true;
      basketTotalEl.textContent = '£0.00';
      return;
    }
    let total = 0;
    basket.forEach((b,i)=>{
      const li = document.createElement('li');
      li.className='list-group-item py-2 d-flex justify-content-between align-items-center';
      total += Number(b.price||0);
      li.innerHTML = `<span>${b.name}</span><span class="ms-2 text-nowrap">${formatPence(b.price||0)}</span><button class="btn btn-sm btn-outline-danger ms-2" data-rm="${i}">&times;</button>`;
      basketList.appendChild(li);
    });
    clearBtn.disabled = false;
    checkoutBtn.disabled = false;
    basketTotalEl.textContent = formatPence(total);
  }

  categoryStrip.addEventListener('click', e => {
    const chip = e.target.closest('.cat-chip');
    if(!chip) return;
    document.querySelectorAll('.cat-chip').forEach(el=>el.classList.remove('active'));
    chip.classList.add('active');
    const catName = chip.dataset.name;
    renderItems(catName);
  });

  itemsContainer.addEventListener('click', async (e) => {
    const btn = e.target.closest('.item-btn');
    if(!btn) return;
    if (btn.dataset.custom === '1') {
      // Decide which modal behavior to use
      const catName = btn.dataset.cat;
      const items = MENU[catName] || [];
      const item = items.find(i => i.name === btn.dataset.name);
      if (!item) return;
      const all = getAllOptionSections(item);
      if (all.sections.length) {
        openCompositeOptionsModal(catName, item);
        return;
      }
      const opts = getOptions(item);
      if (opts.mode === 'addons') {
        openAddonsModal(catName, item);
      } else if (opts.mode === 'radio_free' || opts.mode === 'radio_paid') {
        openRadioFreeModal(catName, item);
      } else {
        openOptionsModal(catName, btn.dataset.name);
      }
    } else {
      basket.push({ name: btn.dataset.name, prod: btn.dataset.prod, price: Number(btn.dataset.price||0) });
      renderBasket();
    }
  });

  // Composite modal: renders all add_on_options_x sections in one flow
  async function openCompositeOptionsModal(catName, item){
    ensureModal();
    const listEl = document.getElementById('optionList');
    const titleEl = document.getElementById('optionTitle');
    const cfg = getAllOptionSections(item);
    titleEl.textContent = `${item.name} (Options)`;
    listEl.innerHTML = '';

    // Ensure prices for any needed choices (addons and paid radios)
    const choiceIds = [];
    cfg.sections.forEach(sec => sec.choices.forEach(ch => choiceIds.push(ch.PRODNUMB)));
    const missing = choiceIds.filter(id => !currentPrices[String(id)]);
    if (missing.length) {
      const params = new URLSearchParams({ band: priceBandSelect.value, prods: [...new Set(missing)].join(',') });
      try {
        const resp = await fetch(`/api/prices?${params.toString()}`);
        if (resp.ok){ const data = await resp.json(); Object.assign(currentPrices, data.prices || {}); }
      } catch {}
    }

    // State tracking per section
    const state = {};

    cfg.sections.forEach((sec, idx) => {
      // Section header
      const head = document.createElement('li');
      head.className = 'list-group-item';
      head.innerHTML = `<div class="fw-semibold">${sec.title} <span class="text-secondary">(${sec.required ? 'Required' : 'Optional'})</span></div>`;
      listEl.appendChild(head);

      if (sec.mode === 'addons'){
        state[sec.id] = { quantities: {} };
        sec.choices.forEach(ch => {
          const pr = (currentPrices[String(ch.PRODNUMB)]||{}).price || 0;
          state[sec.id].quantities[ch.PRODNUMB] = 0;
          const li = document.createElement('li');
          li.className = 'list-group-item d-flex justify-content-between align-items-center';
          li.innerHTML = `
            <div class="d-flex flex-column">
              <span style="font-size:1.05rem;">${ch.name}</span>
              <small class="text-secondary">+${formatPence(pr)}</small>
            </div>
            <div class="d-flex align-items-center gap-2">
              <button class="btn btn-outline-secondary btn-sm" data-combo-minus="${sec.id}:${ch.PRODNUMB}">−</button>
              <span class="fw-semibold" data-combo-qty-for="${sec.id}:${ch.PRODNUMB}">0</span>
              <button class="btn btn-outline-secondary btn-sm" data-combo-plus="${sec.id}:${ch.PRODNUMB}">+</button>
            </div>`;
          listEl.appendChild(li);
        });
      } else if (sec.mode === 'radio_free' || sec.mode === 'radio_paid'){
        state[sec.id] = { selected: null };
        sec.choices.forEach((ch, cidx) => {
          const id = `combo_${sec.id}_${String(ch.PRODNUMB)}_${cidx}`;
          const pr = (currentPrices[String(ch.PRODNUMB)]||{}).price || 0;
          const rightText = (sec.mode === 'radio_paid') ? `<small class="text-secondary">+${formatPence(pr)}</small>` : '<small class="text-secondary">+£0.00</small>';
          const li = document.createElement('li');
          li.className = 'list-group-item d-flex justify-content-between align-items-center';
          li.innerHTML = `
            <label for="${id}" class="d-flex align-items-center gap-3 w-100 m-0" style="cursor:pointer;">
              <input class="form-check-input" type="radio" name="${sec.id}" id="${id}" value="${ch.PRODNUMB}">
              <span class="flex-grow-1" style="font-size:1.05rem;">${ch.name}</span>
              ${rightText}
            </label>`;
          listEl.appendChild(li);
        });
      }
    });

    // Toppings not wanted (overall)
    const tnwLi = renderToppingsNotWanted(listEl, cfg.toppingsNotWanted);

    // Special instructions (overall)
    let noteArea = null;
    if (cfg.specialInstructions) {
      const noteLi = document.createElement('li');
      noteLi.className = 'list-group-item';
      noteLi.innerHTML = `
        <label class="form-label fw-semibold">Special Instructions</label>
        <textarea class="form-control" rows="2" placeholder="Add a note here..." id="combo-note"></textarea>`;
      listEl.appendChild(noteLi);
      noteArea = noteLi.querySelector('#combo-note');
    }

    // Footer actions
    const footer = document.createElement('div');
    footer.className = 'p-3 d-flex justify-content-end gap-2';
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn btn-outline-secondary btn-lg';
    cancelBtn.textContent = 'Cancel';
    const addBtn = document.createElement('button');
    addBtn.className = 'btn btn-primary btn-lg';
    addBtn.textContent = 'Add';
    listEl.appendChild(footer);
    footer.appendChild(cancelBtn);
    footer.appendChild(addBtn);

    const isSectionSatisfied = (sec) => {
      const st = state[sec.id];
      if (!sec.required) return true;
      if (sec.mode === 'addons') {
        const total = Object.values(st.quantities||{}).reduce((a,b)=>a+Number(b||0),0);
        return total > 0;
      }
      if (sec.mode === 'radio_free' || sec.mode === 'radio_paid') return st.selected !== null;
      return true;
    };
    const updateAddEnabledCombo = () => {
      const ok = cfg.sections.every(isSectionSatisfied);
      addBtn.disabled = !ok;
    };
    updateAddEnabledCombo();

    // Events
    listEl.addEventListener('click', (ev) => {
      const plus = ev.target.closest('[data-combo-plus]');
      const minus = ev.target.closest('[data-combo-minus]');
      if (plus || minus){
        const key = (plus||minus).getAttribute(plus?'data-combo-plus':'data-combo-minus');
        const [secId, prodStr] = key.split(':');
        const st = state[secId];
        if (!st || !st.quantities) return;
        const pid = Number(prodStr);
        if (!(pid in st.quantities)) st.quantities[pid] = 0;
        if (plus) st.quantities[pid] += 1; else st.quantities[pid] = Math.max(0, st.quantities[pid]-1);
        const qtyEl = listEl.querySelector(`[data-combo-qty-for="${secId}:${pid}"]`);
        if (qtyEl) qtyEl.textContent = String(st.quantities[pid]);
        updateAddEnabledCombo();
      }
    });
    listEl.addEventListener('change', (ev) => {
      const input = ev.target.closest('input.form-check-input[type="radio"]');
      if (input){
        const secId = input.getAttribute('name');
        if (state[secId]) state[secId].selected = Number(input.value);
        updateAddEnabledCombo();
      }
    });

    // Add button logic
    addBtn.onclick = () => {
      // Compose note
      const tnwSelected = tnwLi ? Array.from(tnwLi.querySelectorAll('input[type="checkbox"]:checked')).map(i=>i.value) : [];
      const tnwNote = tnwSelected.length ? `Toppings not wanted: ${tnwSelected.join(', ')}` : '';
      const rawNote = noteArea ? noteArea.value.trim() : '';
      const noteText = [tnwNote, rawNote].filter(Boolean).join(' | ');
      const baseName = noteText ? `${item.name} — ${noteText}` : item.name;
      const basePrice = (currentPrices[String(item.PRODNUMB)]||{}).price || 0;

      // radio_paid: combine base + chosen price into single line if selected
      const paidSec = cfg.sections.find(s => s.mode === 'radio_paid');
      if (paidSec && state[paidSec.id] && state[paidSec.id].selected !== null){
        const selected = state[paidSec.id].selected;
        const choice = paidSec.choices.find(c => Number(c.PRODNUMB) === Number(selected));
        const choicePrice = (currentPrices[String(selected)]||{}).price || 0;
        const combinedName = `${baseName} - ${choice ? choice.name : ''}`;
        basket.push({ name: combinedName, prod: item.PRODNUMB, price: Number(basePrice + choicePrice) });
      } else {
        // Otherwise add base line if the product has a base price flag or generally desired
        if (item.base_price) {
          basket.push({ name: baseName, prod: item.PRODNUMB, price: Number(basePrice) });
        }
      }

      // radio_free: add free line if selected
      const freeSec = cfg.sections.find(s => s.mode === 'radio_free');
      if (freeSec && state[freeSec.id] && state[freeSec.id].selected !== null){
        const selected = state[freeSec.id].selected;
        const choice = freeSec.choices.find(c => Number(c.PRODNUMB) === Number(selected));
        if (choice){
          basket.push({ name: `${baseName} - ${choice.name} (Dip - Free)`, prod: choice.PRODNUMB, price: 0 });
        }
      }

      // addons: add quantities as separate lines
      const addonsSec = cfg.sections.find(s => s.mode === 'addons');
      if (addonsSec && state[addonsSec.id]){
        const quantities = state[addonsSec.id].quantities || {};
        addonsSec.choices.forEach(ch => {
          const qty = quantities[ch.PRODNUMB] || 0;
          if (qty > 0){
            const pr = (currentPrices[String(ch.PRODNUMB)]||{}).price || 0;
            for (let i=0;i<qty;i++){
              basket.push({ name: `${baseName} - ${ch.name} (Extra)`, prod: ch.PRODNUMB, price: Number(pr) });
            }
          }
        });
      }

      renderBasket();
      safeHideOptionModal();
    };
    cancelBtn.onclick = () => { safeHideOptionModal(); };

    if (optionModal) optionModal.show();
  }

  basketList.addEventListener('click', e => {
    const rm = e.target.getAttribute('data-rm');
    if(rm !== null){
      basket.splice(parseInt(rm,10),1);
      renderBasket();
    }
  });

  clearBtn.addEventListener('click', () => { basket = []; renderBasket(); });

  // When price band changes, refresh current items view and reprice basket items
  priceBandSelect.addEventListener('change', async () => {
    // Re-render items for active category
    const activeChip = document.querySelector('.cat-chip.active');
    const catName = activeChip ? activeChip.dataset.name : (Object.keys(MENU)[0] || null);
    if (catName) {
      await renderItems(catName);
    }
    // Re-fetch prices for basket items grouped by category membership is unknown; fetch all at once
    const prodIds = [...new Set(basket.map(b=>b.prod).filter(Boolean))];
    if (prodIds.length){
      const params = new URLSearchParams({ band: priceBandSelect.value, prods: prodIds.join(',') });
      try {
        const resp = await fetch(`/api/prices?${params.toString()}`);
        if (resp.ok){
          const data = await resp.json();
          const map = data.prices || {};
          basket = basket.map(b => ({...b, price: Number((map[String(b.prod)]||{}).price||0)}));
        }
      } catch {}
    }
    renderBasket();
  });

  // Load MENU then auto-select first category (avoid cache to pick up latest JSON edits)
  const MENU_NO_CACHE_URL = `${MENU_URL}?v=${Date.now()}`;
  fetch(MENU_NO_CACHE_URL, { cache: 'no-store' })
    .then(resp => resp.json())
    .then(data => {
      MENU = data;
  renderCategories();
  const firstCat = categoryStrip.querySelector('.cat-chip');
  if(firstCat){ firstCat.click(); }
      renderBasket();
    })
    .catch(() => {
      itemsContainer.innerHTML = '<div class="text-danger small">Failed to load menu.</div>';
    });

  function ensureModal() {
    if (!optionModal && window.bootstrap) {
      optionModal = new bootstrap.Modal(optionModalEl);
    }
    // Ensure focus is cleared from elements inside before the modal hides (a11y)
    if (!optionModalEl._a11yHooked) {
      optionModalEl.addEventListener('hide.bs.modal', () => {
        const active = document.activeElement;
        if (active && optionModalEl.contains(active)) {
          try { active.blur(); } catch(e) {}
        }
      });
      optionModalEl._a11yHooked = true;
    }
  }

  function safeHideOptionModal(){
    const active = document.activeElement;
    if (active && optionModalEl.contains(active)) {
      try { active.blur(); } catch(e) {}
    }
    if (optionModal) optionModal.hide();
  }

  // Helper: render "Toppings not wanted:" checkbox list
  function renderToppingsNotWanted(listEl, toppings){
    if (!Array.isArray(toppings) || toppings.length === 0) return null;
    const li = document.createElement('li');
    li.className = 'list-group-item';
    const wrap = document.createElement('div');
  wrap.className = 'toppings-not-wanted-group';

    // Header styled like the provided reference (soft warning background)
    const header = document.createElement('div');
    header.className = 'rounded-2 px-3 py-2 mb-2';
    header.style.backgroundColor = '#fff3cd'; // fallback if no Bootstrap subtle color
    header.style.border = '1px solid #ffeeba';
    header.style.color = '#7a5c00';
    header.textContent = 'Toppings not wanted:';
    wrap.appendChild(header);

    // One item per row (mobile friendly)
    const grid = document.createElement('div');
    grid.className = 'row g-2';
    toppings.forEach((t, idx) => {
      const col = document.createElement('div');
      col.className = 'col-12';
      const id = `tnw_${idx}_${Math.random().toString(36).slice(2,7)}`;
      col.innerHTML = `
        <div class="form-check align-items-center d-flex">
          <input class="form-check-input" type="checkbox" id="${id}" value="${t}">
          <label class="form-check-label ms-2" for="${id}">${t}</label>
        </div>`;
      grid.appendChild(col);
    });
    wrap.appendChild(grid);
    li.appendChild(wrap);
    listEl.appendChild(li);
    return li;
  }

  async function openOptionsModal(catName, itemName){
    ensureModal();
    const listEl = document.getElementById('optionList');
    const titleEl = document.getElementById('optionTitle');
    titleEl.textContent = itemName;
    listEl.innerHTML = '';
    const items = MENU[catName] || [];
    const item = items.find(i => i.name === itemName);
    if (!item) return;
  // Ensure we have prices for choices
  const opts = getOptions(item);
  const choices = opts.choices;
    // Fetch any missing prices for choices
    const missing = choices.filter(ch => !currentPrices[String(ch.PRODNUMB)]);
    if (missing.length) {
      const params = new URLSearchParams({ band: priceBandSelect.value, prods: missing.map(m=>m.PRODNUMB).join(',') });
      try {
        const resp = await fetch(`/api/prices?${params.toString()}`);
        if (resp.ok) {
          const data = await resp.json();
          Object.assign(currentPrices, data.prices || {});
        }
      } catch {}
    }
    // Populate choices
    choices.forEach((ch, idx) => {
      const pr = (currentPrices[String(ch.PRODNUMB)]||{}).price || 0;
      const li = document.createElement('li');
      li.className = 'list-group-item d-flex justify-content-between align-items-center';
      li.innerHTML = `<span class=\"me-3\" style=\"font-size:1.15rem;\">${ch.name}</span><button class=\"btn btn-primary btn-lg\" data-choose=\"${idx}\">${formatPence(pr)}</button>`;
      listEl.appendChild(li);
    });
  // Toppings not wanted
  const tnwLi = renderToppingsNotWanted(listEl, opts.toppingsNotWanted);
    // Click handler
    listEl.onclick = (ev) => {
      const btn = ev.target.closest('[data-choose]');
      if (!btn) return;
      const ix = parseInt(btn.getAttribute('data-choose'), 10);
      const ch = choices[ix];
      const pr = (currentPrices[String(ch.PRODNUMB)]||{}).price || 0;
      // Include base item name with the chosen option
      const base = item && item.name ? item.name : itemName;
      // Build note from selected toppings (no explicit textarea in this modal)
      const tnwSelected = tnwLi ? Array.from(tnwLi.querySelectorAll('input[type="checkbox"]:checked')).map(i=>i.value) : [];
      const noteText = tnwSelected.length ? `Toppings not wanted: ${tnwSelected.join(', ')}` : '';
      const baseWithNote = noteText ? `${base} — ${noteText}` : base;
      basket.push({ name: `${baseWithNote} - ${ch.name}`, prod: ch.PRODNUMB, price: Number(pr) });
      renderBasket();
      safeHideOptionModal();
    };
    if (optionModal) optionModal.show();
  }

  // Add-on multi-select modal (quantities + optional note)
  function openAddonsModal(catName, item){
    ensureModal();
    const listEl = document.getElementById('optionList');
    const titleEl = document.getElementById('optionTitle');
  const opts = getOptions(item);
  titleEl.textContent = `${opts.title || item.name}`;
    listEl.innerHTML = '';
    // Build UI: each choice with - qty + and price
    const quantities = {};
    opts.choices.forEach((ch, idx) => {
      const pr = (currentPrices[String(ch.PRODNUMB)]||{}).price || 0;
      quantities[ch.PRODNUMB] = 0;
      const li = document.createElement('li');
      li.className = 'list-group-item d-flex justify-content-between align-items-center';
      li.innerHTML = `
        <div class="d-flex flex-column">
          <span style="font-size:1.05rem;">${ch.name}</span>
          <small class="text-secondary">+${formatPence(pr)}</small>
        </div>
        <div class="d-flex align-items-center gap-2">
          <button class="btn btn-outline-secondary btn-sm" data-minus="${ch.PRODNUMB}">−</button>
          <span class="fw-semibold" data-qty-for="${ch.PRODNUMB}">0</span>
          <button class="btn btn-outline-secondary btn-sm" data-plus="${ch.PRODNUMB}">+</button>
        </div>`;
      listEl.appendChild(li);
    });

  // Toppings not wanted (if any)
  const tnwLi = renderToppingsNotWanted(listEl, opts.toppingsNotWanted);

  // Optional special instructions
    let noteArea = null;
    if (opts.specialInstructions) {
      const noteLi = document.createElement('li');
      noteLi.className = 'list-group-item';
      noteLi.innerHTML = `
        <label class="form-label fw-semibold">Special Instructions</label>
        <textarea class="form-control" rows="2" placeholder="Add a note here..." id="addon-note"></textarea>`;
      listEl.appendChild(noteLi);
      noteArea = noteLi.querySelector('#addon-note');
    }

    // Footer action
    const footer = document.createElement('div');
    footer.className = 'p-3 d-flex justify-content-end gap-2';
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn btn-outline-secondary btn-lg';
    cancelBtn.textContent = 'Cancel';
    const addBtn = document.createElement('button');
    addBtn.className = 'btn btn-primary btn-lg';
    addBtn.textContent = 'Add';
    listEl.appendChild(footer);
    footer.appendChild(cancelBtn);
    footer.appendChild(addBtn);

    // Show required/optional in modal header
    titleEl.textContent = `${opts.title || item.name} (${opts.required ? 'Required' : 'Optional'})`;

    const totalSelected = () => Object.values(quantities).reduce((a,b)=>a+Number(b||0),0);
    const updateAddEnabled = () => { addBtn.disabled = !!(opts.required && totalSelected() === 0); };
    updateAddEnabled();

    // Event handlers for qty
    listEl.onclick = (ev) => {
      const plus = ev.target.closest('[data-plus]');
      const minus = ev.target.closest('[data-minus]');
      if (!plus && !minus) return;
      const key = Number((plus||minus).getAttribute(plus?'data-plus':'data-minus'));
      if (!(key in quantities)) return;
      if (plus) quantities[key] += 1; else quantities[key] = Math.max(0, quantities[key] - 1);
      const qtyEl = listEl.querySelector(`[data-qty-for="${key}"]`);
      if (qtyEl) qtyEl.textContent = String(quantities[key]);
      updateAddEnabled();
    };

  // Add button: push base item and each selected addon as separate basket items
    addBtn.onclick = () => {
      if (opts.required && totalSelected() === 0) return; // guard
      const basePrice = (currentPrices[String(item.PRODNUMB)]||{}).price || 0;
    // Merge toppings not wanted into the note
    const tnwSelected = tnwLi ? Array.from(tnwLi.querySelectorAll('input[type="checkbox"]:checked')).map(i=>i.value) : [];
    const tnwNote = tnwSelected.length ? `TNW: ${tnwSelected.join(', ')}` : '';
    const rawNote = noteArea ? noteArea.value.trim() : '';
    const noteText = [tnwNote, rawNote].filter(Boolean).join(' | ');
      const baseName = noteText ? `${item.name} — ${noteText}` : item.name;
      basket.push({ name: baseName, prod: item.PRODNUMB, price: Number(basePrice) });
      opts.choices.forEach(ch => {
        const qty = quantities[ch.PRODNUMB] || 0;
        if (qty > 0) {
          const pr = (currentPrices[String(ch.PRODNUMB)]||{}).price || 0;
          for (let i=0;i<qty;i++) {
      // Include base item name with addon choice
      basket.push({ name: `${baseName} - ${ch.name} (Extra)`, prod: ch.PRODNUMB, price: Number(pr) });
          }
        }
      });
      renderBasket();
      safeHideOptionModal();
    };
    cancelBtn.onclick = () => { safeHideOptionModal(); };

    if (optionModal) optionModal.show();
  }

  // Radio single-select add-on (free) modal
  async function openRadioFreeModal(catName, item){
    ensureModal();
    const listEl = document.getElementById('optionList');
    const titleEl = document.getElementById('optionTitle');
    const opts = getOptions(item);
  titleEl.textContent = `${opts.title || item.name} (${opts.required ? 'Required' : 'Optional'})`;
    listEl.innerHTML = '';

    // Build selectable list
  let selected = null;

    // For paid radios, ensure we have choice prices
    const needPrices = (opts.mode === 'radio_paid');
    if (needPrices) {
      const missing = opts.choices.filter(ch => !currentPrices[String(ch.PRODNUMB)]);
      if (missing.length) {
        const params = new URLSearchParams({ band: priceBandSelect.value, prods: missing.map(m=>m.PRODNUMB).join(',') });
        try {
          const resp = await fetch(`/api/prices?${params.toString()}`);
          if (resp.ok) {
            const data = await resp.json();
            Object.assign(currentPrices, data.prices || {});
          }
        } catch {}
      }
    }

    // Populate list
    opts.choices.forEach((ch, idx) => {
      const id = `rf_${String(ch.PRODNUMB)}_${idx}`;
      const li = document.createElement('li');
      li.className = 'list-group-item d-flex justify-content-between align-items-center';
      const pr = (currentPrices[String(ch.PRODNUMB)]||{}).price || 0;
      const rightText = (opts.mode === 'radio_paid') ? `<small class="text-secondary">+${formatPence(pr)}</small>` : '<small class="text-secondary">+£0.00</small>';
      li.innerHTML = `
        <label for="${id}" class="d-flex align-items-center gap-3 w-100 m-0" style="cursor:pointer;">
          <input class="form-check-input" type="radio" name="rf_choice" id="${id}" value="${ch.PRODNUMB}">
          <span class="flex-grow-1" style="font-size:1.05rem;">${ch.name}</span>
          ${rightText}
        </label>`;
      listEl.appendChild(li);
    });

  // Toppings not wanted (if any)
  const tnwLi = renderToppingsNotWanted(listEl, opts.toppingsNotWanted);

    // Optional special instructions
  let noteArea = null;
    if (opts.specialInstructions) {
      const noteLi = document.createElement('li');
      noteLi.className = 'list-group-item';
      noteLi.innerHTML = `
        <label class="form-label fw-semibold">Special Instructions</label>
        <textarea class="form-control" rows="2" placeholder="Add a note here..." id="rf-note"></textarea>`;
      listEl.appendChild(noteLi);
      noteArea = noteLi.querySelector('#rf-note');
    }

    // Footer actions
    const footer = document.createElement('div');
    footer.className = 'p-3 d-flex justify-content-end gap-2';
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn btn-outline-secondary btn-lg';
    cancelBtn.textContent = 'Cancel';
    const addBtn = document.createElement('button');
    addBtn.className = 'btn btn-primary btn-lg';
    addBtn.textContent = 'Add';
    listEl.appendChild(footer);
    footer.appendChild(cancelBtn);
    footer.appendChild(addBtn);

    // Selection handling
    listEl.addEventListener('change', (ev) => {
      const input = ev.target.closest('input[name="rf_choice"]');
      if (input) selected = Number(input.value);
    });

    // Disable Add until valid when required
    const updateAddEnabledRF = () => { addBtn.disabled = !!(opts.required && (selected === null)); };
    updateAddEnabledRF();
    listEl.addEventListener('change', updateAddEnabledRF);

  addBtn.onclick = () => {
      if (opts.required && selected === null) return;
      const basePrice = (currentPrices[String(item.PRODNUMB)]||{}).price || 0;
      // Merge toppings not wanted into the note
      const tnwSelected = tnwLi ? Array.from(tnwLi.querySelectorAll('input[type="checkbox"]:checked')).map(i=>i.value) : [];
      const tnwNote = tnwSelected.length ? `TNW: ${tnwSelected.join(', ')}` : '';
      const rawNote = noteArea ? noteArea.value.trim() : '';
      const noteText = [tnwNote, rawNote].filter(Boolean).join(' | ');
      const baseName = noteText ? `${item.name} — ${noteText}` : item.name;

      if (opts.mode === 'radio_paid') {
        // Combine base + choice price into a single line
        if (selected === null) return;
        const selectedChoice = opts.choices.find(ch => Number(ch.PRODNUMB) === Number(selected));
        const choicePrice = (currentPrices[String(selected)]||{}).price || 0;
        const combinedName = `${baseName} - ${selectedChoice ? selectedChoice.name : ''}`;
        basket.push({ name: combinedName, prod: item.PRODNUMB, price: Number(basePrice + choicePrice) });
      } else {
        // Free radio: base line + free option line
        basket.push({ name: baseName, prod: item.PRODNUMB, price: Number(basePrice) });
        if (selected !== null) {
          const selectedChoice = opts.choices.find(ch => Number(ch.PRODNUMB) === Number(selected));
          if (selectedChoice) {
            basket.push({ name: `${baseName} - ${selectedChoice.name} (Dip - Free)`, prod: selectedChoice.PRODNUMB, price: 0 });
          }
        }
      }

      renderBasket();
      safeHideOptionModal();
    };
    cancelBtn.onclick = () => { safeHideOptionModal(); };

    if (optionModal) optionModal.show();
  }
</script>
<style>
  .cat-chip.active { color:#fff; background:#0d6efd; border-color:#0d6efd; }
  .cat-chip.active .badge { background:#fff !important; color:#0d6efd; }
  .item-btn { white-space:normal; }
  /* Touch friendly modal */
  #optionModal .modal-content { border-radius: 1rem; }
  #optionModal .modal-header { padding: 1rem 1.25rem; }
  #optionModal .modal-body { padding: 0.75rem 0; }
  #optionModal .list-group-item { padding: 1rem 1.25rem; min-height: 64px; }
  #optionModal .btn { min-width: 120px; min-height: 48px; }
  @media (min-width: 992px) {
    #optionModal .list-group-item { padding: 1.15rem 1.5rem; }
    #optionModal .btn { min-width: 140px; }
  }
  /* Touch-enlarged checkboxes for Toppings not wanted */
  .toppings-not-wanted-group .form-check-input {
    width: 1.4rem;
    height: 1.4rem;
    margin-top: 0;
    cursor: pointer;
  }
  .toppings-not-wanted-group .form-check-label {
    font-size: 1.05rem;
    padding-top: 2px;
    cursor: pointer;
  }
  .toppings-not-wanted-group .form-check {
    min-height: 2.25rem;
  }
</style>
{% endblock %}

