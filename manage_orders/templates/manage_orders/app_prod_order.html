{% extends 'manage_orders/index.html' %}
{% load static %}
{% block content %}
<!-- <h5 class="mt-3">Create Order</h5> -->
<style>
  .basket-pinned-wrapper{ position:fixed; top:0; right:0; width:380px; max-width:95vw; height:100vh; background:var(--bs-body-bg); border-left:1px solid var(--bs-border-color); z-index:1075; display:flex; flex-direction:column; box-shadow:-2px 0 8px rgba(0,0,0,.15); }
  .basket-pinned-wrapper .offcanvas-header{ border-bottom:1px solid var(--bs-border-color); }
  .basket-pinned-wrapper .offcanvas-body{ flex:1 1 auto; overflow:hidden; }
  .basket-pinned-wrapper .offcanvas-body .flex-grow-1{ overflow:auto; }
  body.basket-pinned #basket-fab{ display:none !important; }
  /* When basket is pinned, give the main page some right padding so content isn't hidden under the fixed basket */
  body.basket-pinned{ padding-right:400px; }
  @media (max-width: 480px){ body.basket-pinned{ padding-right:95vw; } }
  .basket-line-active{ outline:2px solid var(--bs-primary); outline-offset:2px; border-radius:6px; }
  /* Minimal compact adjustment for product cards */
  .product-grid-tight { --bs-gutter-x:.5rem; --bs-gutter-y:.6rem; }
  .product-card-compact .card-body { padding:.55rem .6rem .6rem; }
  .product-card-compact h6 { font-size:.9rem; margin-bottom:.25rem !important; }
  .product-card-compact .fw-semibold { font-size:.75rem; }
  .product-card-compact .price-line { font-size:.8rem; }
  .product-card-compact .badge { font-size:.55rem; }
  @media (min-width: 992px){ .product-card-compact h6 { font-size:.95rem; } }
  /* Basket change pulse */
  @keyframes basketPulse { 0%{ transform:scale(1); box-shadow:0 0 0 0 var(--bs-primary); } 40%{ transform:scale(1.03); box-shadow:0 0 0 .35rem rgba(var(--bs-primary-rgb), .15); } 100%{ transform:scale(1); box-shadow:0 0 0 0 rgba(var(--bs-primary-rgb), 0); } }
  .basket-pulse { animation:basketPulse 550ms ease-out; }
  @media (prefers-reduced-motion: reduce){ .basket-pulse { animation:none; } }
  /* Hint pulse animation for disabled Add button feedback */
  @keyframes hintPulse { 0%{opacity:.6;} 30%{opacity:1;} 100%{opacity:.6;} }
  .hint-pulse{ animation: hintPulse 800ms ease-in-out; }
  /* Category strip: prevent wrap and layout flicker on small screens */
  #category-strip{ scrollbar-gutter: stable both-edges; }
  #category-strip .btn{ white-space:nowrap; flex:0 0 auto; line-height:1.2; padding:.5rem 1rem; border-width:2px; }
  #category-strip .btn.active{ border-width:2px; }
  /* Avoid height jitter on press/active */
  #category-strip .btn:active{ transform:none !important; box-shadow:none !important; }
  /* Slightly reduce font on very small screens to keep a single row */
  @media (max-width: 576px){
    #category-strip{ font-size:1.05rem !important; }
  }
</style>
<style>
  /* Toppings (Modify tab) redesigned as chip toggles */
  #cfg-toppings-list{display:flex;flex-wrap:wrap;gap:.55rem;}
  .topping-chip{--_pad-x:0.9rem;--_pad-y:.55rem;position:relative;border:1px solid var(--bs-border-color);border-radius:2rem;padding:var(--_pad-y) var(--_pad-x);background:var(--bs-body-bg);font-size:.95rem;line-height:1.1;cursor:pointer;user-select:none;display:inline-flex;align-items:center;gap:.4rem;transition:background-color .15s,border-color .15s,color .15s, box-shadow .15s;}
  .topping-chip:hover{background:var(--bs-tertiary-bg);}
  .topping-chip:focus-visible{outline:2px solid var(--bs-primary);outline-offset:2px;}
  .topping-chip.removed{background:rgba(var(--bs-danger-rgb), .08);border-color:rgba(var(--bs-danger-rgb), .6);color:var(--bs-danger-text,#dc3545);text-decoration:line-through;}
  .topping-chip.removed::after{content:'âœ•';font-size:.8rem;opacity:.85;}
  .topping-chip[data-pressed="true"]{box-shadow:0 0 0 .12rem rgba(var(--bs-primary-rgb), .35);} /* accessibility state */
  @media (pointer:coarse){
    .topping-chip{--_pad-x:1.05rem;--_pad-y:.75rem;font-size:1.05rem;}
  }
  #cfg-toppings-actions{display:flex;flex-wrap:wrap;gap:.6rem;margin-top:.35rem;margin-bottom:.25rem;}
  #cfg-toppings-actions .btn-sm{font-size:.7rem;letter-spacing:.5px;text-transform:uppercase;}
</style>
<!-- Channel / Band Selector -->
<div class="mb-3">
  <div class="d-flex flex-wrap align-items-center gap-2 mb-1">
    <!-- <label class="form-label fw-semibold mb-0">Channel / Price Band</label> -->
    <button type="button" id="band-channel-btn" class="btn btn-lg btn-outline-primary" aria-label="Choose channel for price band">Choose Channel</button>
    <span id="band-channel-active" class="badge bg-secondary d-none"></span>
  </div>
  <!-- <div id="band-channel-hint" class="small text-muted mb-2">Select a channel to load menu & prices.</div> -->
  {% if user.is_superuser %}
  <div class="form-check mt-2">
    <input class="form-check-input" type="checkbox" id="toggle-net" />
    <label class="form-check-label" for="toggle-net">Show Net (Ex VAT) Prices</label>
  </div>
  {% endif %}
  <div class="mt-2">
    <label class="form-label small mb-1">VAT Basis</label>
    <div id="basis-buttons" class="d-flex gap-2 flex-wrap">
      <button type="button" class="btn btn-outline-info btn-lg px-3 py-2 active" data-basis="take">Takeaway</button>
      <button type="button" class="btn btn-outline-info btn-lg px-3 py-2" data-basis="eat">Eat-in</button>
    </div>
  </div>
</div>
<!-- Categories below Price Band (horizontal scroll) -->
<div id="categories-section" class="mb-3">
  <div class="fw-semibold small text-uppercase text-secondary mb-2">Categories</div>
  <div id="category-strip" class="d-flex flex-nowrap overflow-auto gap-3 py-3" style="font-size:1.35rem; -webkit-overflow-scrolling: touch;"></div>
</div>

<!-- Items Pane (full width); basket now floating/offcanvas -->
<div id="order-workspace">
  <div id="items-pane" style="max-height:72vh; overflow:auto;">
    <div class="fw-semibold small text-uppercase text-secondary mb-2">Items</div>
  <div id="items-container" class="row product-grid-tight row-cols-2 row-cols-sm-3 row-cols-lg-4 row-cols-xxl-6"><!-- Items injected via JS --></div>
  </div>
</div>

<!-- Floating Basket Button -->
<button id="basket-fab" type="button" class="btn btn-primary rounded-pill shadow-lg position-fixed d-flex align-items-center gap-2" data-bs-toggle="offcanvas" data-bs-target="#basketOffcanvas" aria-controls="basketOffcanvas" style="bottom:1rem; right:1rem; z-index:1080; padding:.9rem 1.2rem; font-size:1.15rem;">
  <span class="badge text-bg-light text-dark" id="basket-fab-count" style="font-size:.95rem; min-width:2rem;">0</span>
  <span>Basket</span>
  <span id="basket-fab-total" class="fw-semibold">Â£0.00</span>
</button>

<!-- Basket Offcanvas (overlay) -->
<div class="offcanvas offcanvas-end" tabindex="-1" id="basketOffcanvas" aria-labelledby="basketOffcanvasLabel" data-bs-scroll="true">
  <div class="offcanvas-header">
    <h5 class="offcanvas-title" id="basketOffcanvasLabel">Basket</h5>
    <div class="d-flex align-items-center gap-2">
      <button type="button" class="btn btn-sm btn-outline-secondary" id="basket-pin-toggle" title="Pin basket" aria-label="Pin basket">
        <span data-pin-icon>ðŸ“Œ</span>
      </button>
      <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
    </div>
  </div>
  <div class="offcanvas-body d-flex flex-column p-0">
    <div class="p-3 border-bottom">
      <div class="small text-uppercase text-secondary fw-semibold">Current Items</div>
    </div>
    <div class="flex-grow-1 overflow-auto p-3">
      <ul class="list-group" id="basket-list" style="font-size:1.15rem;"></ul>
    </div>
    <div class="border-top p-3">
      <div class="d-flex justify-content-between align-items-center mb-3">
        <span class="fw-semibold">Total</span>
        <span id="basket-total" class="fs-4">Â£0.00</span>
      </div>
      <div class="d-flex justify-content-end gap-2 flex-wrap">
        <button class="btn btn-outline-secondary btn-lg px-4 py-2" id="clear-basket" disabled>Clear</button>
        <button class="btn btn-primary btn-lg px-4 py-2" id="checkout" disabled data-bs-dismiss="offcanvas">Checkout</button>
      </div>
    </div>
  </div>
</div>
<!-- Checkout Modal -->
<div class="modal fade" id="checkoutModal" tabindex="-1" aria-modal="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header py-3">
        <h5 class="modal-title fs-3 fw-bold">Confirm Checkout</h5>
        <button type="button" class="btn-close btn-lg" style="transform:scale(1.3);" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="mb-3">
          <span class="form-label fw-semibold d-block mb-2" style="font-size:1.1rem;">Payment Method</span>
          <div id="pay-method-buttons" class="d-flex flex-wrap gap-2">
            <button type="button" class="btn btn-outline-primary pay-method-btn active" data-pay-method="Cash">Cash</button>
            <button type="button" class="btn btn-outline-primary pay-method-btn" data-pay-method="Card">Card</button>
            <button type="button" class="btn btn-outline-primary pay-method-btn" data-pay-method="On Account">On Account</button>
            <button type="button" class="btn btn-outline-primary pay-method-btn" data-pay-method="Voucher">Voucher</button>
            <button type="button" class="btn btn-outline-primary pay-method-btn" data-pay-method="Crew Food">Crew Food</button>
            <button type="button" class="btn btn-outline-primary pay-method-btn" data-pay-method="Waste food">Waste food</button>
          </div>
        </div>
        <div class="mb-2">
          <label class="form-label fw-semibold" for="crew-id" style="font-size:1.1rem;">Crew ID</label>
          <input id="crew-id" class="form-control form-control-lg py-3" style="font-size:1.15rem;" type="text" inputmode="numeric" placeholder="0" value="0" />
          <div id="crew-id-error" class="text-danger small mt-1 d-none">Crew ID is required</div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-lg btn-outline-secondary px-4 py-2" data-bs-dismiss="modal">Cancel</button>
        <button class="btn btn-lg btn-primary px-4 py-2 fw-bold" id="confirm-checkout">Confirm</button>
      </div>
    </div>
  </div>
  </div>
<!-- Focus sentinel (kept early to shift focus away before any modal hide sets aria-hidden) -->
<button type="button" id="focus-sentinel" class="visually-hidden" tabindex="-1" aria-hidden="true">Sentinel</button>
<!-- Cash Calculator Modal -->
<div class="modal fade" id="cashCalcModal" tabindex="-1" aria-modal="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header py-3">
        <h5 class="modal-title fs-3 fw-bold">Cash Calculator</h5>
        <button type="button" class="btn-close btn-lg" style="transform:scale(1.3);" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="row g-3 align-items-stretch">
          <!-- Quick denominations -->
          <div class="col-12 col-md-3 d-grid gap-2">
            <button type="button" class="btn btn-outline-secondary btn-lg" data-cash-denom="500">Â£5</button>
            <button type="button" class="btn btn-outline-secondary btn-lg" data-cash-denom="1000">Â£10</button>
            <button type="button" class="btn btn-outline-secondary btn-lg" data-cash-denom="2000">Â£20</button>
            <button type="button" class="btn btn-outline-secondary btn-lg" data-cash-denom="5000">Â£50</button>
          </div>
          <!-- Keypad -->
          <div class="col-12 col-md-6">
            <div class="d-grid gap-2" id="cash-keypad">
              <div class="d-grid gap-2" style="grid-template-columns: repeat(3, 1fr); display:grid;">
                <button type="button" class="btn btn-outline-primary btn-lg" data-cash-key="1">1</button>
                <button type="button" class="btn btn-outline-primary btn-lg" data-cash-key="2">2</button>
                <button type="button" class="btn btn-outline-primary btn-lg" data-cash-key="3">3</button>
                <button type="button" class="btn btn-outline-primary btn-lg" data-cash-key="4">4</button>
                <button type="button" class="btn btn-outline-primary btn-lg" data-cash-key="5">5</button>
                <button type="button" class="btn btn-outline-primary btn-lg" data-cash-key="6">6</button>
                <button type="button" class="btn btn-outline-primary btn-lg" data-cash-key="7">7</button>
                <button type="button" class="btn btn-outline-primary btn-lg" data-cash-key="8">8</button>
                <button type="button" class="btn btn-outline-primary btn-lg" data-cash-key="9">9</button>
                <button type="button" class="btn btn-outline-secondary btn-lg" data-cash-key="C">C</button>
                <button type="button" class="btn btn-outline-primary btn-lg" data-cash-key="0">0</button>
                <button type="button" class="btn btn-outline-primary btn-lg" data-cash-key="00">00</button>
              </div>
            </div>
          </div>
          <!-- Totals panel -->
          <div class="col-12 col-md-3">
            <div class="border rounded p-3 h-100 d-flex flex-column justify-content-between">
              <div class="mb-2">
                <div class="small text-muted">Basket Total</div>
                <div id="cash-total" class="fs-3 fw-bold">Â£0.00</div>
              </div>
              <div class="mb-2">
                <div class="small text-muted">Money Received</div>
                <div id="cash-received" class="fs-3">Â£0.00</div>
              </div>
              <div>
                <div id="cash-change-label" class="small text-muted">Change</div>
                <div id="cash-change" class="fs-3">Â£0.00</div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer d-flex justify-content-between align-items-center flex-wrap gap-2">
        <div class="btn-group" role="group" aria-label="VAT basis">
          <button type="button" class="btn btn-outline-info" id="cash-basis-take" data-basis="take">Takeaway</button>
          <button type="button" class="btn btn-outline-info" id="cash-basis-eat" data-basis="eat">Eat-In</button>
        </div>
        <div class="d-flex align-items-center gap-2">
          <button type="button" class="btn btn-lg btn-outline-secondary" id="cash-backspace" title="Backspace">âŒ«</button>
          <button type="button" class="btn btn-lg btn-primary fw-bold" id="cash-ok">OK</button>
        </div>
      </div>
    </div>
  </div>
  </div>
<!-- Item Configuration Modal -->
<div class="modal fade" id="itemConfigModal" tabindex="-1" aria-modal="true">
  <div class="modal-dialog modal-lg modal-dialog-scrollable">
    <div class="modal-content">
      <div class="modal-header py-3">
        <h5 class="modal-title fs-3 fw-bold" id="cfg-title">Configure Item</h5>
        <button type="button" class="btn-close btn-lg" style="transform:scale(1.3);" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div id="cfg-loading" class="text-center py-5">Loading...</div>
        <div id="cfg-body" class="d-none">
          <div class="mb-3">
            <div class="d-flex justify-content-between align-items-start gap-2 flex-wrap">
              <div>
                <!-- <strong id="cfg-item-name"></strong> -->
                <span class="badge bg-secondary ms-2 d-none" id="cfg-item-type">Combo</span>
                <span class="badge bg-info text-dark ms-2 d-none" id="cfg-meal-badge">Meal</span>
              </div>
              <div class="text-end small">
                <div><span id="cfg-band"></span></div>
                <div class="d-flex flex-column">
                  <div>Price: <span id="cfg-price-main"></span><span id="cfg-meal-price" class="ms-2 small text-info"></span></div>
                  <div class="small" id="cfg-price-note"></div>
                </div>
              </div>
            </div>
          </div>
          <!-- Config Tabs: Extras appears only when options/choices exist -->
          <div class="mb-3 d-flex gap-2" id="cfg-tabbar">
            <button type="button" class="btn btn-outline-secondary btn-lg px-3 py-2 active" data-cfg-tab="main">Configure</button>
            <button type="button" class="btn btn-outline-secondary btn-lg px-3 py-2 d-none" id="cfg-modify-tab" data-cfg-tab="modify">Modify</button>
          </div>
          <div id="cfg-variants" class="mb-4 d-none">
            <label class="form-label fw-semibold" style="font-size:1.15rem;">Variants</label>
            <div id="cfg-variant-list" class="d-flex flex-wrap gap-3"></div>
          </div>
          <div id="cfg-meal-section" class="border rounded p-3 mb-4 d-none" style="background:var(--bs-tertiary-bg);">
            <div class="form-check form-switch mb-3" style="font-size:1.15rem;">
              <input class="form-check-input" style="width:3rem;height:1.5rem;" type="checkbox" id="cfg-meal-toggle" />
              <label class="form-check-label ms-2" for="cfg-meal-toggle">Convert to Meal</label>
            </div>
            <div id="cfg-meal-components" class="row g-3 d-none">
              <div class="col-md-6 d-none" id="cfg-fries-wrap">
                <label class="form-label fw-semibold" style="font-size:1.05rem;">Fries</label>
                <select id="cfg-fries" class="form-select form-select-lg py-3" style="font-size:1.15rem;"></select>
              </div>
              <div class="col-md-6" id="cfg-drinks-wrap">
                <label class="form-label fw-semibold" style="font-size:1.05rem;">Drink</label>
                <div id="cfg-drink-list" class="d-flex flex-wrap gap-2"></div>
              </div>
            </div>
            <div class="mt-2 d-none" id="cfg-sizeup-wrap" style="font-size:1.05rem;">
              <label class="form-label fw-semibold me-2 mb-2">Size Up</label>
              <div id="cfg-sizeup-group" class="btn-group flex-wrap" role="group" aria-label="Size up">
                <button type="button" class="btn btn-outline-secondary active" data-sizeup="none">None</button>
                <button type="button" class="btn btn-outline-secondary" data-sizeup="both">Both</button>
                <button type="button" class="btn btn-outline-secondary" data-sizeup="drink">Drink only</button>
                <button type="button" class="btn btn-outline-secondary" data-sizeup="fries">Fries only</button>
              </div>
            </div>
          </div>
          <div id="cfg-toppings" class="mb-4 d-none">
            <div id="cfg-add-extras" class="mb-3 d-none">
              <label class="form-label fw-semibold mb-2" style="font-size:1.15rem;">Add Extras</label>
              <div id="cfg-add-extras-list" class="d-flex flex-wrap gap-2"></div>
            </div>
            <div class="d-flex justify-content-between align-items-center mb-1 flex-wrap gap-2">
              <label class="form-label fw-semibold mb-0" style="font-size:1.15rem;">Modify Toppings</label>
              <div id="cfg-toppings-actions" class="d-none">
                <button type="button" class="btn btn-sm btn-outline-secondary" id="cfg-top-restore">Restore All</button>
                <button type="button" class="btn btn-sm btn-outline-danger" id="cfg-top-remove-all">Remove All</button>
              </div>
            </div>
            <div id="cfg-toppings-list"></div>
            <div id="cfg-toppings-note" class="form-text">Tap to toggle. Strikethrough = will be removed.</div>
          </div>
          <!-- Combo structure UI disabled per request
          <div id="cfg-combo-structure" class="mb-4 d-none">
            <label class="form-label fw-semibold" style="font-size:1.15rem;">Combination Components</label>
            <div class="row g-2">
              <div class="col-md-6">
                <div class="border rounded p-3 h-100" style="font-size:1.05rem;">
                  <div class="fw-semibold mb-2" style="font-size:1.05rem;">Compulsory</div>
                  <ul id="cfg-compulsory" class="mb-0 list-unstyled"></ul>
                </div>
              </div>
              <div class="col-md-6">
                <div class="border rounded p-3 h-100" style="font-size:1.05rem;">
                  <div class="fw-semibold mb-2" style="font-size:1.05rem;">Optional <span class="text-muted" id="cfg-free-optional"></span></div>
                  <div id="cfg-optional" class="d-flex flex-column gap-2"></div>
                </div>
              </div>
            </div>
          </div>
          -->
          <!-- Free Choices Section (dynamic, inserted/updated by JS) -->
          <div id="cfg-free-choices" class="mb-4 d-none">
            <label class="form-label fw-semibold" style="font-size:1.15rem;">Free Choices</label>
            <div id="cfg-free-choices-groups" class="d-flex flex-column gap-3"></div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <div id="cfg-add-hint" class="small text-danger d-none" style="max-width:260px; text-align:right;"></div>
        <button class="btn btn-lg btn-outline-secondary px-4 py-2" data-bs-dismiss="modal">Cancel</button>
        <button class="btn btn-lg btn-primary px-4 py-2 fw-bold position-relative" id="cfg-add-btn" disabled>Add to Basket</button>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
(function(){
  // Custom lightweight style injection for topping buttons (touch friendly)
  const styleId='topping-buttons-style';
  if(!document.getElementById(styleId)){
    const st=document.createElement('style'); st.id=styleId; st.textContent = `
      .topping-btn { min-height:70px; font-size:1.15rem; letter-spacing:0.5px; }
      @media (pointer:coarse){ .topping-btn { min-height:80px; font-size:1.25rem; } }
    `; document.head.appendChild(st);
  }
  // Hide floating basket button while any offcanvas is open (Bootstrap adds body.offcanvas-open)
  if(!document.getElementById('basket-fab-hide-style')){
    const st2=document.createElement('style'); st2.id='basket-fab-hide-style';
    st2.textContent = `body.offcanvas-open #basket-fab{display:none !important;}`; // must override Bootstrap .d-flex !important
    document.head.appendChild(st2);
  }
  // Ensure when basket is pinned, any offcanvas backdrop is hidden and does not block interactions
  if(!document.getElementById('basket-pinned-backdrop-style')){
    const st3=document.createElement('style'); st3.id='basket-pinned-backdrop-style';
    st3.textContent = `body.basket-pinned .offcanvas-backdrop{display:none !important;}`;
    document.head.appendChild(st3);
  }
  const bandButtonsWrap = null; // removed band buttons UI
  const basisButtonsWrap = document.getElementById('basis-buttons');
  const categoryStrip = document.getElementById('category-strip');
  const itemsContainer = document.getElementById('items-container');
  const basketList = document.getElementById('basket-list');
  const basketTotal = document.getElementById('basket-total');
  const clearBtn = document.getElementById('clear-basket');
  const checkoutBtn = document.getElementById('checkout');
  const basketFab = document.getElementById('basket-fab');
  const basketFabCount = document.getElementById('basket-fab-count');
  const basketFabTotal = document.getElementById('basket-fab-total');
  const basketOffcanvasEl = document.getElementById('basketOffcanvas');
  if(basketOffcanvasEl){
    basketOffcanvasEl.addEventListener('show.bs.offcanvas', ()=>{ if(basketFab) basketFab.classList.add('d-none'); });
    basketOffcanvasEl.addEventListener('hidden.bs.offcanvas', ()=>{ if(basketFab) basketFab.classList.remove('d-none'); });
  }
  let currentBand = '1';
  let currentChannelName = '';
  let vatBasis = 'take'; // default
  let showNet = false;
  let bandCoNumber = '';
  let isThirdPartyDelivery = false; // from selected channel
  let CHANNEL_ENTRIES = [];
  // Expose superuser flag for conditional UI (embed as string to avoid JS parse issues in editors)
  const IS_SUPERUSER = "{% if user.is_superuser %}1{% else %}0{% endif %}" === '1';
  const HOT_DRINKS_GROUP_ID = 11;
  let hotDrinkCodes = new Set();
  function prefetchHotDrinkCodes(){
    hotDrinkCodes = new Set();
    // fetch once per band selection and return a promise
    return fetch(`/api/menu/category/${HOT_DRINKS_GROUP_ID}/items?band=${currentBand}`)
      .then(r=>r.json())
      .then(data=>{
        const arr = (data.items||[]);
        arr.forEach(it=>{ if(it && typeof it.code === 'number') hotDrinkCodes.add(it.code); });
      })
      .catch(()=>{/* non-blocking */});
  }
  function loadChannels(){
    fetch('/api/channels')
      .then(r=>r.json())
      .then(data=>{
        CHANNEL_ENTRIES = (data.channels||[]).map(c=>({ band:c.band, desc:c.name, code:c.channel_code, co:c.co_number, third: !!c.is_third_party_delivery }));
        // Prompt user to choose a channel
        if(typeof openChannelModal === 'function') openChannelModal();
      })
      .catch(()=>{});
  }

  function applyChannelSelection(band, co, desc, fetch=true, code){
    currentBand = String(band);
    currentChannelName = desc || '';
    bandCoNumber = co || '';
    const badge = document.getElementById('band-channel-active');
    if(badge){ badge.textContent = `${desc} (${bandCoNumber})`; badge.classList.remove('d-none'); }
    // resolve third-party flag
    const match = CHANNEL_ENTRIES.find(c=> (code? c.code===code : (c.band==band && c.co===co && c.desc===desc)) );
    isThirdPartyDelivery = !!(match && match.third);
    // pre-fetch hot drink codes for filtering (used in meal config and possibly categories)
    const done = prefetchHotDrinkCodes();
    activeCategoryId = null;
    if(fetch){
      // Ensure categories load proceeds; we don't strictly need to wait, but chain for robustness
      Promise.resolve(done).finally(()=> fetchMenu());
    }
  }
  let currentItems = [];
  // Categories and items cache for per-category item lists
  let categories = [];
  const catItemsCache = {};
  let activeCategoryId = null;

  const basket = { lines:[], total:0 };
  // Track the signature of the last added non-topping line so toppings can attach to it
  let lastProductSignature = null;
  // Incrementing counter to create unique topping groups
  let toppingGroupCounter = 1;
  let lastRemovedTopping = null; // last removed topping line for undo
  let undoTimer = null;

  // Modal / config state
  const cfgModalEl = document.getElementById('itemConfigModal');
  let cfgModal = null; const ensureModal=()=>{ if(!cfgModal) cfgModal = new bootstrap.Modal(cfgModalEl); };
  const cfg = { data:null, currentVariant:null, meal:false, fries:null, drink:null, optionalSelected:new Set(), effectivePrice:0, sizeup:'none' };
  cfg.toppings = []; // full list of topping objects {acode, desc, menu_desc}
  cfg.toppingsLoaded = false;
  cfg.addonsSelected = new Set();
  let cfgTab = 'main';

  function money(pence){ return 'Â£' + (pence/100).toFixed(2); }

  // Subtle color accents per item (use EPOS_PROD RGB when available; fallback to deterministic hash hue)
  function colorAccentForItem(prod){
    // Prefer server-provided RGB colour from EposProd
    const c = prod && prod.colour;
    const hasRGB = c && Number.isFinite(c.r) && Number.isFinite(c.g) && Number.isFinite(c.b);
    if(hasRGB){
      const r = Math.max(0, Math.min(255, c.r|0));
      const g = Math.max(0, Math.min(255, c.g|0));
      const b = Math.max(0, Math.min(255, c.b|0));
      // Keep backgrounds very subtle to preserve text contrast
      const bgLight = `rgba(${r}, ${g}, ${b}, 0.08)`;   // pastel tint on light theme
      const borderLight = `rgb(${r}, ${g}, ${b})`;      // solid border
      const bgDark = `rgba(${r}, ${g}, ${b}, 0.12)`;    // slightly stronger tint on dark
      const borderDark = `rgba(${r}, ${g}, ${b}, 0.85)`; // lighter/visible border in dark
      return { bgLight, borderLight, bgDark, borderDark };
    }
    // Fallback: deterministic, subtle HSL hue based on code/name
    const s = String(prod?.code ?? prod?.name ?? '');
    let hash = 0;
    for(let i=0;i<s.length;i++){ hash = ((hash << 5) - hash) + s.charCodeAt(i); hash |= 0; }
    const hue = Math.abs(hash) % 360; // stable hue per item
    const bgLight = `hsl(${hue}, 85%, 97%)`;
    const borderLight = `hsl(${hue}, 65%, 45%)`;
    const bgDark = `hsla(${hue}, 80%, 60%, 0.08)`;
    const borderDark = `hsl(${hue}, 70%, 60%)`;
    return { bgLight, borderLight, bgDark, borderDark };
  }

  function isDarkTheme(){
    const attr = document.documentElement.getAttribute('data-bs-theme');
    if(attr){ return attr.toLowerCase() === 'dark'; }
    return !!(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches);
  }

  function fetchMenu(){
    // Reset caches when band changes
    categories = [];
    currentItems = [];
    for(const k of Object.keys(catItemsCache)) delete catItemsCache[k];
    itemsContainer.innerHTML='';
    categoryStrip.innerHTML='<div class="text-muted small">Loading...</div>';
  fetch(`/api/menu/categories?band=${currentBand}&include_empty=1`)
      .then(r=>r.json())
      .then(data=>{ 
        categories = data.categories || []; 
        // If third-party delivery, exclude Hot Drinks category (group 11)
        if(isThirdPartyDelivery){ categories = categories.filter(c=> String(c.id) !== String(HOT_DRINKS_GROUP_ID)); }
        // injectStaticCategories();
        renderCategories(); 
        autoSelectFirst(); 
      })
      .catch(err=>{ console.error('Categories load error', err); categoryStrip.innerHTML='<div class="text-danger small">Failed to load</div>'; });
  }

  // --- Static custom categories (e.g. Toppings) ---
  const TOPPINGS_CAT_ID = '__TOPPINGS__';
  const TOPPINGS = [
    'cheese','lettuce','tomato','onions','garlic','chilli','mayo','ketchup','mustard','dills'
  ];
  function injectStaticCategories(){
    // Append toppings category (avoid duplicates on re-fetch)
    if(!categories.find(c=> c.id===TOPPINGS_CAT_ID)){
      categories.push({ id: TOPPINGS_CAT_ID, name: 'Toppings', item_count: TOPPINGS.length, source_type:'S' });
    }
  }

  function renderCategories(){
    const prevScroll = categoryStrip.scrollLeft || 0;
    categoryStrip.innerHTML='';
    (categories||[]).forEach(cat=>{
      const btn = document.createElement('button');
      btn.className = 'btn btn-outline-secondary text-nowrap';
      btn.textContent = cat.name;
      if(IS_SUPERUSER){
  // Auto-open channel chooser if no band selected yet so tests/UI can progress
  if(!bandCoNumber){
    setTimeout(()=>{ try { openChannelModal(); } catch(e){} }, 50);
  }
        btn.textContent += (cat.item_count? ` (${cat.item_count})` : '');
      }
      btn.dataset.catId = cat.id;
      if(cat.id === activeCategoryId) btn.classList.add('active');
      btn.addEventListener('click', ()=>{ selectCategory(cat.id); });
      categoryStrip.appendChild(btn);
    });
    // Inject Paid Out button at end only for allowed bands 1 and 5
    if(String(currentBand)==='1' || String(currentBand)==='5'){
      const paidBtn = document.createElement('button');
      paidBtn.id = 'paid-out-btn';
      paidBtn.className = 'btn btn-outline-secondary text-nowrap'; // match category style
      paidBtn.textContent = 'Paid Out';
      paidBtn.addEventListener('click', ()=>{ openPaidOut(); });
      categoryStrip.appendChild(paidBtn);
    }
    // Restore scroll position to avoid noticeable jump/flicker on re-render
    categoryStrip.scrollLeft = prevScroll;
  }

  function setActiveCategoryButton(){
    const btns = categoryStrip.querySelectorAll('button[data-cat-id]');
    btns.forEach(b => b.classList.toggle('active', String(b.dataset.catId) === String(activeCategoryId)));
  }

  function autoSelectFirst(){
    if(!activeCategoryId && (categories||[]).length){
      selectCategory(categories[0].id);
    } else if(activeCategoryId){
      selectCategory(activeCategoryId);
    }
  }

  function selectCategory(catId){
    activeCategoryId = catId;
    // Only toggle button active state instead of rebuilding all to avoid flicker
    setActiveCategoryButton();
    itemsContainer.innerHTML = '<div class="text-muted small">Loading items...</div>';
    if(catId === TOPPINGS_CAT_ID){
      renderToppings();
      return;
    }
    if(catItemsCache[catId]){
      currentItems = catItemsCache[catId];
      renderProducts();
      return;
    }
    fetch(`/api/menu/category/${catId}/items?band=${currentBand}`)
      .then(r=>r.json())
      .then(data=>{ currentItems = data.items || []; catItemsCache[catId] = currentItems; renderProducts(); })
      .catch(err=>{ console.error('Items load error', err); itemsContainer.innerHTML='<div class="text-danger small">Failed to load items</div>'; });
  }

  function priceForDisplay(prod){
    // Prefer precomputed Kids Meal composite price for kids items when available
    if(prod && prod.meal_type === 'kids'){
      if(showNet){
        if(vatBasis==='eat'){
          return Number.isFinite(prod.kids_meal_price_net_eat) ? prod.kids_meal_price_net_eat : prod.price_net_eat;
        }
        return Number.isFinite(prod.kids_meal_price_net_take) ? prod.kids_meal_price_net_take : prod.price_net_take;
      }
      return Number.isFinite(prod.kids_meal_price_gross) ? prod.kids_meal_price_gross : prod.price_gross;
    }
    if(showNet){ return vatBasis==='eat'? prod.price_net_eat : prod.price_net_take; }
    return prod.price_gross;
  }

  function priceForDiscountDisplay(prod){
    if(showNet){ return vatBasis==='eat'? prod.discounted_price_net_eat : prod.discounted_price_net_take; }
    return prod.discounted_price_gross;
  }

  function renderProducts(){
    itemsContainer.innerHTML='';
    if(!currentItems || currentItems.length===0){ return; }
    currentItems.forEach(prod=>{
    const col = document.createElement('div');
    col.className='col';
  const card = document.createElement('div'); card.className='card h-100 shadow-sm product-card-compact';
  // Apply subtle color accents per item (left border + theme-aware background)
  const acc = colorAccentForItem(prod);
  const dark = isDarkTheme();
  card.style.borderLeft = `6px solid ${dark ? acc.borderDark : acc.borderLight}`;
  card.style.backgroundColor = dark ? acc.bgDark : acc.bgLight;
      // Make card the click target
  card.setAttribute('data-open', String(prod.code));
      card.setAttribute('data-item-type', prod.type);
      card.style.cursor = 'pointer';
  const basePrice = priceForDisplay(prod);
  const isKids = (prod.meal_type === 'kids');
  const priceHtml = `<span class='fs-5 fw-bold'>${money(basePrice)}</span>${showNet? ' <span class=\"text-muted small\">ex VAT</span>':''}`;
    const codeHtml = IS_SUPERUSER ? ` <span class='text-muted small'>#${prod.code}</span>` : '';
  const mealLabel = isKids ? 'Kids Meal' : 'Meal';
  const mealBadge = prod.meal_flag ? ` <span class='badge bg-info text-dark'>${mealLabel}</span>` : '';
    // For Kids items we already show the meal price, so hide the discount badge
    const discountHtml = isKids ? '' : (prod.has_discount ? ` <span class='badge bg-warning text-dark'>Meal ${money(priceForDiscountDisplay(prod))}</span>` : '');
      let variantsHtml='';
      if(prod.variants && prod.variants.length){
        variantsHtml = `<div class='mt-1 small d-flex flex-wrap gap-1'>` + prod.variants.map(v=>{
          return `<span class='badge text-bg-light' role='button' data-var='${v.code}' data-parent='${prod.code}' data-item-type='product' title='${v.label}'>${v.label}: ${money(v.price_gross)}</span>`; }).join('') + `</div>`;
      }
      card.innerHTML = `<div class=\"card-body d-flex flex-column\">        
        <h6 class=\"card-title text-truncate\" title=\"${prod.name}\">${prod.name}${mealBadge}</h6>
  <div class=\"price-line fw-semibold mb-1\">${priceHtml}${discountHtml}${codeHtml}</div>
        ${variantsHtml}
        <div class=\"mt-auto\"></div>
      </div>`;
      col.appendChild(card); itemsContainer.appendChild(col);
    });
  }

  function renderToppings(){
    itemsContainer.innerHTML='';
    const frag=document.createDocumentFragment();
    TOPPINGS.forEach(name=>{
      const norm = name.toLowerCase();
      const col=document.createElement('div'); col.className='col-6 col-md-4 col-xl-3';
  col.innerHTML = `\n        <div class='card h-100 shadow-sm border-2'>\n          <div class='card-body d-flex flex-column'>\n            <h6 class='card-title mb-3 text-truncate fs-5' title='${name}'>${name.charAt(0).toUpperCase()+name.slice(1)}</h6>\n            <div class='mt-auto d-flex flex-column gap-3'>\n              <button type='button' class='btn btn-outline-danger btn-lg fw-semibold topping-btn' data-topping-action='remove' data-topping='${norm}'>Remove</button>\n              <button type='button' class='btn btn-outline-success btn-lg fw-semibold topping-btn' data-topping-action='extra' data-topping='${norm}'>Extra Portion</button>\n            </div>\n          </div>\n        </div>`;
      frag.appendChild(col);
    });
    itemsContainer.appendChild(frag);
  }

  function findItem(type, code){
    // Search current items first, then any cached category
    for(const it of (currentItems||[])){ if(it.type===type && it.code==code) return it; }
    for(const catId of Object.keys(catItemsCache)){
      const arr = catItemsCache[catId] || [];
      for(const it of arr){ if(it.type===type && it.code==code) return it; }
    }
    return null;
  }

  function addLine(line){
    // For non-topping lines compute a baseSignature (without toppings) used for merging.
    if(line.type !== 'topping'){
      line.baseSignature = createBaseSignature(line);
      // Attempt merge only if there is an existing line with same baseSignature and no toppings yet.
      const existing = basket.lines.find(l=> l.type !== 'topping' && l.baseSignature === line.baseSignature && !lineHasToppings(l));
      if(existing){
        existing.qty = (existing.qty||1) + (line.qty||1);
        lastProductSignature = existing.signature; // keep pointing to the merged line
      } else {
        // New line: assign toppingGroup null initially; signature == baseSignature
        line.toppingGroup = null;
        line.signature = line.baseSignature;
        basket.lines.push({...line, qty: line.qty||1});
        lastProductSignature = line.signature;
      }
    } else {
      // Topping pseudo-line: signature derived from target product signature to keep uniqueness
      line.signature = createLineSignature(line);
      basket.lines.push({...line, qty:1});
    }
    renderBasket();
  }
  function createBaseSignature(line){
    const meta = line.meta || {};
    const opts = (meta.options||[]).slice().sort((a,b)=>a-b).join('-');
    const fries = meta.fries || '';
    const drink = meta.drink || '';
    const variant = line.variant || '';
    return [line.code, variant, line.meal?1:0, fries, drink, opts].join('|');
  }
  function lineHasToppings(prodLine){
    return basket.lines.some(t=> t.type==='topping' && t.meta?.targetSig === prodLine.signature);
  }
  function ensureToppingGroup(prodLine){
    if(prodLine.toppingGroup == null){
      prodLine.toppingGroup = toppingGroupCounter++;
      prodLine.signature = prodLine.baseSignature + '|T' + prodLine.toppingGroup;
    }
    return prodLine.toppingGroup;
  }
  function createLineSignature(line){
    if(line.type === 'topping'){
      const meta = line.meta || {};
      const target = meta.targetSig || 'NONE';
      return [line.code, 'TOPPING', target].join('|');
    }
    // Non-topping lines rely on existing signature
    return line.signature || line.baseSignature;
  }
  function renderBasket(){
    // We'll recompute total from product lines including any attached priced extras per unit
    basket.total = 0;
    basketList.innerHTML='';
    // Exclude topping pseudo-lines from direct display
    const displayLines = basket.lines.filter(l=> l.type !== 'topping');
    let recomputedTotal = 0;
    displayLines.forEach((l,idx)=>{
      const li=document.createElement('li');
      li.className='list-group-item';
      li.dataset.lineSig = l.signature;
      if(l.signature === lastProductSignature){ li.classList.add('basket-line-active'); }
      // Build choices/details list
      let details = [];
      const meta = l.meta || {};
      if(meta.display_choices && meta.display_choices.length){
        details = meta.display_choices.map(dc=> `<li>${dc}</li>`);
      } else {
        // Legacy: derive basic details from meta codes if names not stored
        if(meta.fries) details.push(`<li>Fries: #${meta.fries}</li>`);
        if(meta.drink) details.push(`<li>Drink: #${meta.drink}</li>`);
        if(meta.options && meta.options.length){ details.push(`<li>Options: ${meta.options.map(o=>'#'+o).join(', ')}</li>`); }
      }
      const detailsHtml = details.length? `<ul class='small text-muted mb-1 ms-2 list-unstyled'>${details.join('')}</ul>` : '';
      // Attach any toppings referencing this line's signature
      const attachedToppings = basket.lines.filter(t=> t.type==='topping' && t.meta?.targetSig === l.signature);
      let toppingsHtml='';
      if(attachedToppings.length){
        const topsLi = attachedToppings.map(t=>{
          const isKindExtra = t.meta && t.meta.kind === 'extra';
          const isRemove = !isKindExtra && /(^|\s)no\s/i.test(t.name);
          const isExtraByName = !isKindExtra && /extra/i.test(t.name);
          const cls = isKindExtra? 'text-success' : (isRemove? 'text-danger' : (isExtraByName? 'text-success' : 'text-info'));
          const idxRef = basket.lines.indexOf(t);
          const badge = isKindExtra? "<span class='badge bg-success me-1'>+</span>" : (isRemove? "<span class='badge bg-danger-subtle text-danger-emphasis me-1'>NO</span>" : "<span class='badge bg-secondary me-1'>ADD</span>");
          const priceSpan = isKindExtra && t.price ? ` <span class='text-muted'>(+${money(t.price)})</span>` : '';
          // Avoid duplicated 'No' like 'NO No Onions' by stripping leading 'No ' from the name when a NO badge is present
          const baseName = (t.name||'');
          const displayName = isRemove ? baseName.replace(/^\s*no\s+/i, '').trim() : baseName;
          const label = `${badge} ${displayName}${priceSpan}`;
          return `<li class='${cls}' data-topping-line='${idxRef}'>${label} <button type='button' class='btn btn-sm btn-link p-0 ms-1 text-decoration-none text-muted' data-remove-topping='${idxRef}' aria-label='Remove attached' title='Remove'>&times;</button></li>`;
        });
        toppingsHtml = `<ul class='small mb-1 ms-2 list-unstyled toppings-list' data-parent-sig='${l.signature}'>${topsLi.join('')}</ul>`;
      }
  const customBadge = attachedToppings.length? " <span class='badge bg-warning text-dark ms-1' style='font-size:0.65rem;'>CUSTOM</span>" : '';
  // Include attached priced extras per unit for display and total recomputation
  const extrasSum = attachedToppings.reduce((s,t)=> s + ((t.meta && t.meta.kind === 'extra') ? (t.price||0) : 0), 0);
  const lineDisplayPence = (l.price + extrasSum) * (l.qty||1);
  recomputedTotal += lineDisplayPence;
      li.innerHTML = `<div class='d-flex justify-content-between align-items-start gap-2'>
        <div class='flex-grow-1'>
          <div class='basket-line-main' data-select-line='${l.signature}' role='button'>${l.name}${l.variant? ' ('+l.variant+')':''}${l.meal? (l.meal_type==='kids'?' Kids Meal':' Meal'):''}${customBadge}</div>
          ${detailsHtml}
          ${toppingsHtml}
        </div>
        <div class='d-flex align-items-center gap-2'>
          <div class='btn-group btn-group-sm' role='group'>
            <button class='btn btn-outline-secondary' data-dec='${basket.lines.indexOf(l)}'>&minus;</button>
            <span class='px-2'>${l.qty||1}</span>
            <button class='btn btn-outline-secondary' data-inc='${basket.lines.indexOf(l)}'>&plus;</button>
          </div>
          <div class='text-end'>
            <div class='fw-semibold'>${money(lineDisplayPence)}</div>
            <button class='btn btn-outline-danger mt-1 d-inline-flex align-items-center justify-content-center'
                    style='width:40px;height:40px;border-width:2px;'
                    data-del='${basket.lines.indexOf(l)}' title='Remove' aria-label='Remove item'>
              <svg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 16 16' fill='currentColor' aria-hidden='true'>
                <path d='M5.5 5.5a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v7a.5.5 0 0 0 1 0v-7z'/>
                <path fill-rule='evenodd' d='M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2h4.118a1 1 0 0 1 .94.658L6.5 3h3l.442-1.342A1 1 0 0 1 10.882 2H15v1zM4.118 4 4 4v9a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4H4.118zM2.5 3V2h11v1h-11z'/>
              </svg>
            </button>
          </div>
        </div>
      </div>`;
      basketList.appendChild(li);
  });
  basket.total = recomputedTotal;
  basketTotal.textContent = money(basket.total);
    clearBtn.disabled = displayLines.length===0; checkoutBtn.disabled = displayLines.length===0;
    const totalQty = displayLines.reduce((s,l)=> s + (l.qty||1),0);
    if(basketFabCount) basketFabCount.textContent = totalQty;
    if(basketFabTotal) basketFabTotal.textContent = money(basket.total);
    if(basketFab){
      basketFab.classList.toggle('btn-outline-secondary', displayLines.length===0);
      basketFab.disabled = displayLines.length===0;
    }
    // Animate basket changes (FAB + list container pulse)
    const pulse = (el)=>{ if(!el) return; el.classList.remove('basket-pulse'); void el.offsetWidth; el.classList.add('basket-pulse'); setTimeout(()=> el.classList.remove('basket-pulse'), 600); };
    pulse(basketFab);
    pulse(document.getElementById('basketOffcanvas'));
  }
  clearBtn.addEventListener('click', ()=>{ basket.lines=[]; lastProductSignature=null; renderBasket(); });
  // Pin / Unpin basket logic
  const pinToggleBtn = document.getElementById('basket-pin-toggle');
  let basketPinned = false;
  const offcanvasEl = document.getElementById('basketOffcanvas');
  // Ensure FAB reliably opens offcanvas even after pin/unpin cycles by forcing show via API on first click when needed
  if(basketFab && window.bootstrap){
    basketFab.addEventListener('click', (ev)=>{
      if(basketPinned) return; // FAB hidden when pinned anyway
      const inst = window.bootstrap.Offcanvas.getOrCreateInstance(offcanvasEl, { scroll:true, backdrop:true });
      // If offcanvas isn't currently shown, force show and prevent the data-api toggle from double-toggling
      if(!offcanvasEl.classList.contains('show')){ ev.preventDefault(); inst.show(); }
    }, true); // capture to run before Bootstrap's data-api handler
  }
  function applyPinState(){
    if(basketPinned){
      document.body.classList.add('basket-pinned');
      offcanvasEl.classList.add('basket-pinned-wrapper','show');
      offcanvasEl.style.visibility='visible';
      offcanvasEl.style.transform='none';
      // Remove existing backdrop & body lock
      document.querySelectorAll('.offcanvas-backdrop').forEach(b=> b.remove());
      document.body.classList.remove('offcanvas-open','modal-open');
      // Clear any inline scroll locks Bootstrap may have applied
      try {
        document.body.style.overflow = '';
        document.body.style.paddingRight = '';
        document.documentElement.style.overflow = '';
      } catch(_){}
      pinToggleBtn.title='Unpin basket'; pinToggleBtn.setAttribute('aria-label','Unpin basket');
      pinToggleBtn.querySelector('[data-pin-icon]').textContent='ðŸ“';
      if(basketFab){ basketFab.classList.add('d-none'); basketFab.style.display='none'; }
    } else {
      document.body.classList.remove('basket-pinned');
      offcanvasEl.classList.remove('basket-pinned-wrapper');
      offcanvasEl.style.transform='';
      pinToggleBtn.title='Pin basket'; pinToggleBtn.setAttribute('aria-label','Pin basket');
      pinToggleBtn.querySelector('[data-pin-icon]').textContent='ðŸ“Œ';
      // Ensure our manual pinned state is removed; Offcanvas API handles showing on next FAB click
      offcanvasEl.classList.remove('show');
      offcanvasEl.style.visibility='';
      if(basketFab){ basketFab.classList.remove('d-none'); basketFab.style.display=''; }
    }
  }
  if(pinToggleBtn){
    pinToggleBtn.addEventListener('click', ()=>{
      const inst = window.bootstrap ? window.bootstrap.Offcanvas.getOrCreateInstance(offcanvasEl) : null;
      const targetPinned = !basketPinned;
      if(targetPinned){
        // Going to pinned: fully dispose Offcanvas instance so internal state resets
        try { inst && inst.dispose && inst.dispose(); } catch(_){}
        basketPinned = true;
      } else {
        // Going to unpinned: flip flag first so hide prevention doesn't fire, then dispose instance
        basketPinned = false;
        try { inst && inst.dispose && inst.dispose(); } catch(_){}
      }
      applyPinState();
      // Persist user preference
      try { localStorage.setItem('epos_basket_pinned', basketPinned ? '1' : '0'); } catch(_) {}
    });
  }
  // Prevent Bootstrap auto-dismiss when pinned
  offcanvasEl.addEventListener('hide.bs.offcanvas', (e)=>{ if(basketPinned){ e.preventDefault(); } });
  // Load user preference on startup (default to pinned)
  try {
    const saved = localStorage.getItem('epos_basket_pinned');
    if(saved === null){
      basketPinned = true;
    } else {
      basketPinned = (saved === '1' || saved === 'true');
    }
  } catch(_) { basketPinned = true; }
  applyPinState();
  // Checkout flow opens modal to collect payment method and crew ID
  let checkoutModal = null; const ensureCheckoutModal=()=>{ if(!checkoutModal){ checkoutModal = new bootstrap.Modal(document.getElementById('checkoutModal')); } };
  // Cash calculator modal helpers/state
  let cashModal = null; const ensureCashModal=()=>{ if(!cashModal){ cashModal = new bootstrap.Modal(document.getElementById('cashCalcModal')); } };
  const cashState = { receivedPence: 0 };
  function setCashBasisButtons(){
    const takeBtn = document.getElementById('cash-basis-take');
    const eatBtn = document.getElementById('cash-basis-eat');
    if(!takeBtn || !eatBtn) return;
    takeBtn.classList.toggle('active', vatBasis==='take');
    eatBtn.classList.toggle('active', vatBasis==='eat');
  }
  function moneyPence(p){ return money(p); }
  function updateCashUI(){
    const total = basket.total||0;
    const recv = cashState.receivedPence||0;
    const change = recv - total;
    const lbl = document.getElementById('cash-change-label');
    const out = document.getElementById('cash-change');
    document.getElementById('cash-total').textContent = moneyPence(total);
    document.getElementById('cash-received').textContent = moneyPence(recv);
    if(change >= 0){
      lbl.textContent = 'Change'; out.textContent = moneyPence(change); out.classList.remove('text-danger'); out.classList.add('text-success');
    } else {
      lbl.textContent = 'Balance Due'; out.textContent = moneyPence(Math.abs(change)); out.classList.add('text-danger'); out.classList.remove('text-success');
    }
    // Enable OK always; cashier may accept partial and settle separately (business choice)
    const okBtn = document.getElementById('cash-ok'); if(okBtn){ okBtn.disabled = false; }
  }
  function openCashCalculator(crewId){
    ensureCashModal();
    cashState.receivedPence = 0;
    setCashBasisButtons();
    updateCashUI();
    cashModal.show();
    // focus a sensible control (e.g., first keypad button) for keyboard users
    const firstKey = document.querySelector('[data-cash-key="1"]'); if(firstKey){ try{ firstKey.focus({preventScroll:true}); }catch(e){} }
    // attach one-time handlers (delegated)
  }
  checkoutBtn.addEventListener('click', ()=>{ if(!basket.lines.length) return; ensureCheckoutModal(); document.getElementById('crew-id-error').classList.add('d-none'); checkoutModal.show(); });
  // Payment method button group (touch friendly)
  document.addEventListener('click', (e)=>{
    const btn = e.target.closest('.pay-method-btn');
    if(btn && btn.closest('#pay-method-buttons')){
      const wrap = document.getElementById('pay-method-buttons');
      wrap.querySelectorAll('.pay-method-btn').forEach(b=> b.classList.remove('active'));
      btn.classList.add('active');
    }
  });
  document.getElementById('confirm-checkout').addEventListener('click', ()=>{
  const activePayBtn = document.querySelector('#pay-method-buttons .pay-method-btn.active');
  const payMethod = activePayBtn ? activePayBtn.getAttribute('data-pay-method') : 'Cash';
    const crewId = (document.getElementById('crew-id').value||'').trim();
    if(crewId===''){
      document.getElementById('crew-id-error').classList.remove('d-none');
      return;
    }
    // For Cash, show calculator first; others submit directly
    if(payMethod === 'Cash'){
      checkoutModal.hide();
      // Defer opening to after modal hides to avoid focus clash
      setTimeout(()=> openCashCalculator(crewId), 150);
      // Store crewId on the OK handler closure
      const okBtn = document.getElementById('cash-ok');
      if(okBtn){
        okBtn.onclick = ()=>{
          // proceed to submit order with Cash
          cashModal.hide();
          submitOrder({ payment_method: 'Cash', crew_id: crewId });
        };
      }
    } else {
      checkoutModal.hide();
      submitOrder({ payment_method: payMethod, crew_id: crewId });
    }
  });

  // Cash keypad and controls
  document.addEventListener('click', (e)=>{
    const denomBtn = e.target.closest('[data-cash-denom]');
    if(denomBtn){ const add = parseInt(denomBtn.getAttribute('data-cash-denom'),10)||0; cashState.receivedPence = (cashState.receivedPence||0) + add; updateCashUI(); return; }
    const keyBtn = e.target.closest('[data-cash-key]');
    if(keyBtn){
      const key = keyBtn.getAttribute('data-cash-key');
      if(key === 'C'){ cashState.receivedPence = 0; updateCashUI(); return; }
      if(key === '00'){ cashState.receivedPence = Math.min(999999999, (cashState.receivedPence||0) * 100); updateCashUI(); return; }
      // digits 0-9: shift-left (pence-style) and add digit
      const d = parseInt(key,10); if(!Number.isNaN(d)){
        const cur = cashState.receivedPence||0;
        cashState.receivedPence = Math.min(999999999, cur*10 + d);
        updateCashUI();
      }
      return;
    }
    const back = e.target.closest('#cash-backspace'); if(back){ cashState.receivedPence = Math.floor((cashState.receivedPence||0)/10); updateCashUI(); return; }
    const basisTake = e.target.closest('#cash-basis-take'); if(basisTake){ vatBasis='take'; setCashBasisButtons(); /* Optional: re-render prices */ renderProducts(); renderBasket(); return; }
    const basisEat = e.target.closest('#cash-basis-eat'); if(basisEat){ vatBasis='eat'; setCashBasisButtons(); renderProducts(); renderBasket(); return; }
  });

  itemsContainer.addEventListener('click', (e)=>{
    const toppingBtn = e.target.closest('[data-topping-action]');
    if(toppingBtn){
      const topping = toppingBtn.getAttribute('data-topping');
      const action = toppingBtn.getAttribute('data-topping-action');
      if(topping && action){
        if(!lastProductSignature){
          alert('Add a product before applying toppings.');
          return;
        }
        const isRemove = action==='remove';
        const lineName = (isRemove? 'No ' : 'Extra ') + topping.charAt(0).toUpperCase()+topping.slice(1);
        const targetLine = basket.lines.find(l=> l.signature === lastProductSignature && l.type !== 'topping');
        if(!targetLine){ return; }
        if(targetLine.qty > 1){
          targetLine.qty -= 1;
          const clone = { ...targetLine, qty:1 };
          basket.lines.push(clone);
          lastProductSignature = clone.signature; // operate on clone for toppings
        }
        ensureToppingGroup(targetLine);
        lastProductSignature = targetLine.signature;
        const toppingLine = { code: `TOPPING_${topping.toUpperCase()}_${isRemove? 'NO':'EXTRA'}`, name: lineName, price:0, type:'topping', meta:{ topping, action, targetSig: targetLine.signature } };
        addLine(toppingLine);
      }
      return;
    }
    const variant = e.target.closest('[data-var]');
    if(variant){ openConfig('product', variant.dataset.parent, variant.dataset.var); return; }
    const openCard = e.target.closest('[data-open]');
    if(openCard){
      const type = openCard.getAttribute('data-item-type');
      const code = openCard.getAttribute('data-open');
      const base = findItem(type, code);
  // Configuration needed only for combos, variants, or meal-capable items (product options removed)
  const needsConfig = type==='combo' || (base && ((base.variants&&base.variants.length) || base.meal_flag));
      if(needsConfig){ openConfig(type, code, null); }
      else if(base){
        const grpId = base.epos_group_id || base.group_id || null;
        const isExtras = String(grpId) === '8' || String(activeCategoryId) === '8';
        // Extras (EPOS_GROUP_ID = 8) cannot be sold standalone; attach to last added product
        if(isExtras){
          if(!lastProductSignature){
            alert('Add a product before adding an extra.');
            return;
          }
          const targetLine = basket.lines.find(l=> l.signature === lastProductSignature && l.type !== 'topping');
          if(!targetLine){ return; }
          // If target has qty > 1, split off one unit for customization
          if(targetLine.qty > 1){
            targetLine.qty -= 1;
            const clone = { ...targetLine, qty:1 };
            basket.lines.push(clone);
            lastProductSignature = clone.signature;
          }
          ensureToppingGroup(targetLine);
          lastProductSignature = targetLine.signature;
          const extraLine = { code: base.code, name: base.name, price: base.price_gross||0, type:'topping', meta:{ kind:'extra', targetSig: targetLine.signature, extra_product_code: base.code } };
          addLine(extraLine);
        } else {
          addLine({ code: base.code, name: base.name, qty:1, price: base.price_gross, type: base.type });
        }
      }
      return;
    }
  });

  basketList.addEventListener('click', (e)=>{
    const inc = e.target.closest('[data-inc]');
    if(inc){ const i=parseInt(inc.dataset.inc,10); basket.lines[i].qty++; renderBasket(); return; }
    const dec = e.target.closest('[data-dec]');
    if(dec){ const i=parseInt(dec.dataset.dec,10); basket.lines[i].qty--; if(basket.lines[i].qty<=0) basket.lines.splice(i,1); renderBasket(); return; }
    const del = e.target.closest('[data-del]');
    if(del){ const i=parseInt(del.dataset.del,10); const lineToDelete=basket.lines[i]; if(lineToDelete && lineToDelete.signature){ basket.lines = basket.lines.filter(l=> l!==lineToDelete && !(l.type==='topping' && l.meta?.targetSig===lineToDelete.signature)); } else { basket.lines.splice(i,1);} renderBasket(); return; }
    const removeTopBtn = e.target.closest('[data-remove-topping]');
    if(removeTopBtn){ const idx=parseInt(removeTopBtn.dataset.removeTopping,10); if(!isNaN(idx) && basket.lines[idx] && basket.lines[idx].type==='topping'){ const removed = basket.lines.splice(idx,1)[0]; lastRemovedTopping = removed; maybeRevertCustomizedLine(removed.meta?.targetSig); showUndoToast(); renderBasket(); } return; }
    const selectLine = e.target.closest('[data-select-line]');
    if(selectLine){ lastProductSignature = selectLine.dataset.selectLine; renderBasket(); return; }
  });

  function maybeRevertCustomizedLine(sig){
    if(!sig) return;
    const prod = basket.lines.find(l=> l.signature === sig && l.type !== 'topping');
    if(!prod) return;
    const stillHas = basket.lines.some(t=> t.type==='topping' && t.meta?.targetSig === sig);
    if(!stillHas && prod.toppingGroup != null){
      prod.toppingGroup = null;
      prod.signature = prod.baseSignature;
      const existing = basket.lines.find(l=> l!==prod && l.type!=='topping' && l.signature===prod.baseSignature && !lineHasToppings(l));
      if(existing){ existing.qty += prod.qty; basket.lines = basket.lines.filter(l=> l!==prod); }
    }
  }
  function showUndoToast(){
    clearTimeout(undoTimer);
    let toast = document.getElementById('undo-toast');
    if(!toast){
      toast = document.createElement('div');
      toast.id='undo-toast';
      toast.className='alert alert-secondary shadow-sm d-flex align-items-center gap-3 py-2 px-3';
      Object.assign(toast.style,{position:'fixed',bottom:'1rem',left:'50%',transform:'translateX(-50%)',zIndex:2000});
      toast.innerHTML = `<span class='small flex-grow-1'>Topping removed</span><button type='button' class='btn btn-sm btn-outline-primary' id='undo-btn'>Undo</button>`;
      document.body.appendChild(toast);
    }
    toast.classList.remove('d-none');
    document.getElementById('undo-btn').onclick = ()=>{ if(lastRemovedTopping){ basket.lines.push(lastRemovedTopping); lastRemovedTopping=null; toast.classList.add('d-none'); renderBasket(); } };
    undoTimer = setTimeout(()=>{ if(toast){ toast.classList.add('d-none'); lastRemovedTopping=null; } },5000);
  }

  function openConfig(type, code, preVariant){
    ensureModal();
    cfg.data=null; cfg.currentVariant=preVariant; cfg.meal=false; cfg.fries=null; cfg.drink=null; cfg.optionalSelected.clear();
    document.getElementById('cfg-loading').classList.remove('d-none');
    document.getElementById('cfg-body').classList.add('d-none');
    document.getElementById('cfg-add-btn').disabled=true;
    cfgModal.show();
    fetch(`/api/item/${type}/${code}/detail?band=${currentBand}`)
      .then(r=>r.json())
      .then(d=>{ cfg.data=d.item; populateConfig(); })
      .catch(()=>{ document.getElementById('cfg-loading').textContent='Failed to load'; });
  }

  function populateConfig(){
    const data = cfg.data; if(!data) return;
    document.getElementById('cfg-title').textContent = `${data.name}`;
    if(IS_SUPERUSER)document.getElementById('cfg-title').textContent += ` (#${data.code})`;   
    // document.getElementById('cfg-item-name').textContent = data.name;
    document.getElementById('cfg-item-type').classList.toggle('d-none', data.type!=='combo');
    const cfgMealBadgeEl = document.getElementById('cfg-meal-badge');
    cfgMealBadgeEl.classList.toggle('d-none', !data.meal_flag);
    if (data.meal_flag) {
      cfgMealBadgeEl.textContent = (data.meal_type === 'kids') ? 'Kids Meal' : 'Meal';
    }
    document.getElementById('cfg-band').textContent = currentBand;
    // Replace band number with channel name when available
    if(currentChannelName){
      document.getElementById('cfg-band').textContent = currentChannelName;
    }
    // Variants
    const vWrap = document.getElementById('cfg-variants');
    const vList = document.getElementById('cfg-variant-list'); vList.innerHTML='';
    if(data.variants && data.variants.length){
      vWrap.classList.remove('d-none');
      data.variants.forEach(v=>{
        const btn=document.createElement('button'); btn.type='button'; btn.className='btn btn-sm btn-outline-secondary';
        btn.textContent = `${v.label} ${money(v.price_gross)}`; btn.dataset.code=v.code;
        if(cfg.currentVariant && cfg.currentVariant==v.code) btn.classList.add('active');
        btn.addEventListener('click',()=>{ cfg.currentVariant=v.code; [...vList.children].forEach(c=>c.classList.remove('active')); btn.classList.add('active'); updateConfigPrice(); });
        vList.appendChild(btn);
      });
    } else vWrap.classList.add('d-none');
    // Meal
  const mealSection = document.getElementById('cfg-meal-section');
    const mealToggle = document.getElementById('cfg-meal-toggle');
    const mealComp = document.getElementById('cfg-meal-components');
  const friesSel = document.getElementById('cfg-fries');
  const drinkList = document.getElementById('cfg-drink-list'); friesSel.innerHTML=''; if(drinkList) drinkList.innerHTML='';
  const sizeUpWrap = document.getElementById('cfg-sizeup-wrap');
  const sizeUpGroup = document.getElementById('cfg-sizeup-group');
  function resetSizeUp(){
    cfg.sizeup = 'none';
    if(sizeUpGroup){
      sizeUpGroup.querySelectorAll('[data-sizeup]').forEach(b=>{
        b.classList.toggle('active', b.getAttribute('data-sizeup')==='none');
      });
    }
  }
    // Determine Kids Meal (Meal Id = 2) and disable Size Up in that case
    const mealId = data.meal_id || data.mealId || null;
    const isKidsByType = (data.meal_type === 'kids');
    const isKidsById = (String(mealId) === '2');
    const grpIdLocal = data.epos_group_id || data.group_id || null;
    const isKidsByGroup = (String(grpIdLocal) === '4');
    const isKidsMeal = isKidsById || isKidsByType || isKidsByGroup;
    const applySizeUpAvailability = (disable)=>{
      if(sizeUpGroup){
        sizeUpGroup.querySelectorAll('[data-sizeup]').forEach(b=>{
          b.disabled = !!disable;
          b.classList.toggle('disabled', !!disable);
        });
      }
    };
    const friesWrap = document.getElementById('cfg-fries-wrap');
    const drinksWrap = document.getElementById('cfg-drinks-wrap');
  if(data.meal_flag && data.meal_components && data.meal_components.fries && data.meal_components.fries.length){
      mealSection.classList.remove('d-none');
    mealToggle.checked=false; mealComp.classList.add('d-none');
  sizeUpWrap.classList.add('d-none');
  applySizeUpAvailability(isKidsMeal);
    resetSizeUp();
      friesWrap.classList.add('d-none');
      // Populate fries (we'll auto-select regular when toggle on)
      const friesList = (data.meal_components.fries||[]);
      friesList.forEach(f=>{ const o=document.createElement('option'); o.value=f.code; o.textContent=`${f.name} ${money(f.price_gross)}`; friesSel.appendChild(o); });
      // Filter drinks: only regular where T_DRINK_CD > 0
      let regularDrinks = (data.meal_components.drinks||[]).filter(d=> (d.T_DRINK_CD||d.t_drink_cd||0) > 0);
      // Exclude hot drinks (EPOS_GROUP=11) for third-party delivery channels
      if(isThirdPartyDelivery && hotDrinkCodes && hotDrinkCodes.size){
        regularDrinks = regularDrinks.filter(d=> !hotDrinkCodes.has(d.code));
      }
      if(regularDrinks.length===0){ regularDrinks = (data.meal_components.drinks||[]); }
      // Render drink buttons (no price)
      if(drinkList){
        drinkList.innerHTML='';
        regularDrinks.forEach(dr=>{
          const b=document.createElement('button'); b.type='button'; b.className='btn btn-outline-info';
          b.textContent = dr.name; b.dataset.code = dr.code; b.dataset.tDrinkCd = dr.T_DRINK_CD || dr.t_drink_cd || 0;
          b.addEventListener('click', ()=>{
            cfg.drink = parseInt(b.dataset.code,10);
            // toggle active state
            [...drinkList.children].forEach(c=> c.classList.remove('active'));
            b.classList.add('active');
            updateConfigPrice();
          });
          drinkList.appendChild(b);
        });
        // If only one drink is available, preselect it
        if(drinkList.children.length === 1){
          const only = drinkList.children[0];
          only.classList.add('active');
          cfg.drink = parseInt(only.getAttribute('data-code')||only.dataset.code,10);
        }
      }
      // Defaults when toggled on: select first regular fries and require a drink choice
  friesSel.selectedIndex = -1; cfg.fries=null; cfg.drink=null;
      mealToggle.onchange=()=>{
        cfg.meal=mealToggle.checked;
        mealComp.classList.toggle('d-none', !cfg.meal);
  const allowSizeUp = cfg.meal && !isKidsMeal;
  sizeUpWrap.classList.toggle('d-none', !allowSizeUp);
  applySizeUpAvailability(!allowSizeUp);
  if(!allowSizeUp){ resetSizeUp(); }
        if(cfg.meal){
          // Auto-select regular fries (assume first option is Regular)
          resetSizeUp();
          if(friesSel.options.length>0){ friesSel.selectedIndex=0; cfg.fries=parseInt(friesSel.value,10); }
        } else {
          cfg.fries=null; cfg.drink=null; 
          resetSizeUp();
        }
        updateConfigPrice();
      };
    friesSel.onchange=()=>{ cfg.fries=friesSel.value? parseInt(friesSel.value,10):null; updateConfigPrice(); };
  // drink selection handled via buttons above
      if(sizeUpGroup){
        resetSizeUp();
        sizeUpGroup.addEventListener('click', (e)=>{
          if(isKidsMeal) return; // ignore clicks when Size Up is disabled for Kids Meal
          const btn = e.target.closest('[data-sizeup]'); if(!btn) return;
          const val = btn.getAttribute('data-sizeup');
          cfg.sizeup = val;
          [...sizeUpGroup.querySelectorAll('[data-sizeup]')].forEach(b=> b.classList.toggle('active', b===btn));
          updateConfigPrice();
        });
      }
  } else mealSection.classList.add('d-none');
    // Product options feature removed â€“ intentionally no rendering or pricing adjustments here.
    // Add Extras rendering (moved under Modify tab)
    const addExtrasWrap = document.getElementById('cfg-add-extras');
    const addExtrasList = document.getElementById('cfg-add-extras-list'); addExtrasList.innerHTML='';
    cfg.addonsSelected = new Set();
    const modifyTabBtnEl = document.getElementById('cfg-modify-tab');
    if(data.addons && data.addons.length){
      addExtrasWrap.classList.remove('d-none');
      // Ensure Modify tab is shown even if no toppings are available
      modifyTabBtnEl?.classList.remove('d-none');
      data.addons.forEach(a=>{
        const btn=document.createElement('button');
        btn.type='button';
        btn.className='btn btn-outline-primary';
        btn.dataset.addonCode=String(a.code);
        btn.setAttribute('aria-pressed','false');
        btn.textContent = `${a.name} ${money(a.price_gross||0)}`;
        btn.addEventListener('click', ()=>{
          const code=parseInt(btn.dataset.addonCode,10);
          const nowActive = btn.classList.toggle('active');
          btn.setAttribute('aria-pressed', nowActive? 'true':'false');
          if(nowActive) cfg.addonsSelected.add(code); else cfg.addonsSelected.delete(code);
          updateConfigPrice();
        });
        addExtrasList.appendChild(btn);
      });
    } else {
      addExtrasWrap.classList.add('d-none');
    }
    // Free choices (if present)
    const freeChoiceWrap = document.getElementById('cfg-free-choices');
    const freeGroupsContainer = document.getElementById('cfg-free-choices-groups');
    const renderFreeChoices = () => {
      if(!freeGroupsContainer) return;
      freeGroupsContainer.innerHTML='';
      const groups = (data && data.free_choice_groups) || [];
      if(groups.length){
        if(freeChoiceWrap) freeChoiceWrap.classList.remove('d-none');
        groups.forEach((g,gi)=>{
          const groupId = `freegrp-${(data && data.code)||'X'}-${gi}`;
          const inner = document.createElement('div');
          inner.className='border rounded p-3';
          inner.innerHTML = `<div class='fw-semibold mb-2 small'>Pick 1 free</div>`;
          const optListDiv=document.createElement('div'); optListDiv.className='d-flex flex-wrap gap-2';
          (g.options||[]).forEach(o=>{
            const btn=document.createElement('button');
            btn.type='button'; btn.className='btn btn-outline-success';
            btn.dataset.freeChoiceGroup=groupId; btn.dataset.freeChoiceCode=o.code;
            btn.textContent = o.name;
            btn.addEventListener('click', ()=>{
              // Single selection per group: toggle active state
              optListDiv.querySelectorAll(`button[data-free-choice-group='${groupId}']`).forEach(b=> b.classList.remove('active'));
              btn.classList.add('active');
            });
            optListDiv.appendChild(btn);
          });
          inner.appendChild(optListDiv);
          freeGroupsContainer.appendChild(inner);
        });
      } else {
        if(freeChoiceWrap) freeChoiceWrap.classList.add('d-none');
      }
    };
    renderFreeChoices();
    // Load toppings (Modify tab) only for products (not combos) when opening config.
    const modifyTabBtn = document.getElementById('cfg-modify-tab');
    const toppingsWrap = document.getElementById('cfg-toppings');
    const toppingsList = document.getElementById('cfg-toppings-list');
    toppingsList.innerHTML='';
    cfg.toppings = []; cfg.toppingsLoaded = false;
    if(data.type==='product'){
      fetch(`/api/product/${data.code}/toppings`)
        .then(r=> r.ok? r.json(): Promise.reject())
        .then(resp=>{
          const tops = resp.toppings || [];
          cfg.toppings = tops.map((t,i)=> ({ ...t, idx:i, removed:false }));
          cfg.toppingsLoaded = true;
          if(cfg.toppings.length || (data.addons && data.addons.length)){
            modifyTabBtn?.classList.remove('d-none');
            const actionsBar = document.getElementById('cfg-toppings-actions');
            actionsBar?.classList.remove('d-none');
            cfg.toppings.forEach(tp=>{
              const name = (tp.menu_desc || tp.desc || '').trim();
              if(!name) return;
              const chip = document.createElement('button');
              chip.type='button';
              chip.className='topping-chip';
              chip.textContent = name;
              chip.dataset.topIndex = String(tp.idx);
              chip.setAttribute('aria-pressed','false');
              chip.addEventListener('click',()=> toggleChip(chip));
              chip.addEventListener('keydown',(ev)=>{ if(ev.key===' '||ev.key==='Enter'){ ev.preventDefault(); toggleChip(chip);} });
              toppingsList.appendChild(chip);
            });
            // Actions: Remove All / Restore All
            const btnRestore = document.getElementById('cfg-top-restore');
            const btnRemoveAll = document.getElementById('cfg-top-remove-all');
            if(btnRestore){ btnRestore.onclick = ()=>{ cfg.toppings.forEach(tp=> tp.removed=false); refreshChips(); }; }
            if(btnRemoveAll){ btnRemoveAll.onclick = ()=>{ cfg.toppings.forEach(tp=> tp.removed=true); refreshChips(); }; }
          } else modifyTabBtn?.classList.add('d-none');
        })
        .catch(()=>{ modifyTabBtn?.classList.add('d-none'); });
    } else modifyTabBtn?.classList.add('d-none');
    // Product options API fallback removed along with UI; combos still supported.
    // Combo structure UI disabled per request
    /*
    const comboStruct = document.getElementById('cfg-combo-structure');
    const compUL = document.getElementById('cfg-compulsory');
    const optDiv = document.getElementById('cfg-optional');
    const freeLbl = document.getElementById('cfg-free-optional'); compUL.innerHTML=''; optDiv.innerHTML='';
    if(data.type==='combo'){
      comboStruct.classList.remove('d-none');
      (data.compulsory||[]).forEach(c=>{ compUL.insertAdjacentHTML('beforeend', `<li>${c.name} ${money(c.price_gross)}</li>`); });
      if(data.optional && data.optional.length){
        freeLbl.textContent = '';
        data.optional.forEach(o=>{
          const id=`opt-combo-${o.code}`;
          optDiv.insertAdjacentHTML('beforeend', `<div class='form-check'><input class='form-check-input' type='checkbox' id='${id}' data-combo-opt='${o.code}'><label class='form-check-label small' for='${id}'>${o.name} ${money(o.price_gross)}</label></div>`);
        });
        optDiv.addEventListener('change', e=>{ const cb=e.target.closest('[data-combo-opt]'); if(cb){ const code=parseInt(cb.dataset.comboOpt,10); if(cb.checked) cfg.optionalSelected.add(code); else cfg.optionalSelected.delete(code); updateConfigPrice(); }});
      }
    } else comboStruct.classList.add('d-none');
    */

    // Extras tab visibility (show when product choices or combo optionals exist)
    const hasAddons = !!(data.addons && data.addons.length);
    cfgTab = 'main';
    syncConfigTabs();
  updateConfigPrice();
  document.getElementById('cfg-loading').classList.add('d-none');
  document.getElementById('cfg-body').classList.remove('d-none');
  // Do NOT force-enable the Add button here; updateConfigPrice controls gating

    // Enforce Kids category (EPOS Group 4) and Kids Meal (Meal Id = 2) as meal-only: auto-toggle and lock; disable Size Up
    try {
      const grpId = data.epos_group_id || data.group_id || null;
      const isKidsGroup = String(grpId) === '4' || (data.meal_type === 'kids') || (String(data.meal_id||data.mealId||'')==='2');
      if(isKidsGroup && !document.getElementById('cfg-body').classList.contains('d-none')){
        if(mealSection && !mealSection.classList.contains('d-none')){
          mealToggle.checked = true; mealToggle.disabled = true; // lock toggle
          // Reveal components and default fries/drink if needed
          mealComp.classList.remove('d-none');
          // For Kids Meal, disable and hide Size Up
          sizeUpWrap.classList.add('d-none');
          applySizeUpAvailability(true);
          resetSizeUp();
          if(friesSel.options.length>0 && (cfg.fries==null || cfg.fries==undefined)){
            friesSel.selectedIndex = 0; cfg.fries = parseInt(friesSel.value,10);
          }
          if(drinkList && drinkList.children.length){
            // If none active, preselect first
            const active = Array.from(drinkList.children).find(c=> c.classList.contains('active'));
            if(!active){ drinkList.children[0].classList.add('active'); cfg.drink = parseInt(drinkList.children[0].getAttribute('data-code')||drinkList.children[0].dataset.code,10); }
          }
          cfg.meal = true;
          updateConfigPrice();
        }
      } else {
        // Ensure toggle is enabled for non-kids groups
        if(mealToggle) mealToggle.disabled = false;
        applySizeUpAvailability(false);
      }
    } catch(err) { /* non-blocking */ }
  }

  function syncConfigTabs(){
    const tabbar = document.getElementById('cfg-tabbar');
    if(tabbar){
      const btns = tabbar.querySelectorAll('[data-cfg-tab]');
      btns.forEach(b=> b.classList.toggle('active', b.getAttribute('data-cfg-tab')===cfgTab));
    }
    const data = cfg.data; if(!data) return;
  const hasAddons = !!(data.addons && data.addons.length);
    // Reset default visibility based on data
    const vWrap = document.getElementById('cfg-variants');
    const mealSection = document.getElementById('cfg-meal-section');
    // const comboStruct = document.getElementById('cfg-combo-structure'); // disabled
    const toppingsWrap = document.getElementById('cfg-toppings');
    const addExtrasWrap = document.getElementById('cfg-add-extras');
    if(vWrap) vWrap.classList.toggle('d-none', !(data.variants && data.variants.length));
    const mealOkay = data.meal_flag && data.meal_components && data.meal_components.fries && data.meal_components.fries.length;
    if(mealSection) mealSection.classList.toggle('d-none', !mealOkay);
    // if(comboStruct) comboStruct.classList.toggle('d-none', data.type!=='combo');
    // If on Extras tab, focus only on extras lists
    // Configure tab now always shows product options and combo optional column (when present)
    const compUL = document.getElementById('cfg-compulsory');
    const compCol = compUL ? compUL.closest('.col-md-6') : null;
    const optCol = document.getElementById('cfg-optional')?.closest('.col-md-6');
    if(compCol) compCol.classList.remove('d-none');
    if(optCol) optCol.classList.remove('d-none');
    // Modify tab visibility (already toggled when toppings loaded); show only its section when active
    if(toppingsWrap){
      const onModify = (cfgTab==='modify');
      toppingsWrap.classList.toggle('d-none', !onModify);
      if(addExtrasWrap) addExtrasWrap.classList.toggle('d-none', !onModify);
      if(cfgTab==='modify'){
        // Hide other sections when in modify view for clarity
        if(vWrap) vWrap.classList.add('d-none');
        if(mealSection) mealSection.classList.add('d-none');
        // if(comboStruct) comboStruct.classList.add('d-none');
      }
    }
  }
  function toggleChip(chip){
    const idx = parseInt(chip.dataset.topIndex||'-1',10);
    const tp = cfg.toppings.find(t=> t.idx===idx);
    if(!tp) return;
    tp.removed = !tp.removed;
    refreshChip(chip, tp);
  }
  function refreshChips(){
    document.querySelectorAll('#cfg-toppings-list .topping-chip').forEach(ch=>{
      const idx = parseInt(ch.dataset.topIndex||'-1',10);
      const tp = cfg.toppings.find(t=> t.idx===idx);
      if(tp) refreshChip(ch, tp);
    });
  }
  function refreshChip(chip, tp){
    chip.classList.toggle('removed', !!tp.removed);
    chip.setAttribute('aria-pressed', tp.removed? 'true':'false');
  }

  // Tab click handler
  document.addEventListener('click', (e)=>{
    const btn = e.target.closest('#cfg-tabbar [data-cfg-tab]');
    if(!btn) return;
    cfgTab = btn.getAttribute('data-cfg-tab');
    syncConfigTabs();
  });

  function enforceComboFreeLimit(data){
    if(!data.free_optional_count) return;
    const chosen=[...cfg.optionalSelected];
    if(chosen.length<=data.free_optional_count) return;
    const extras=chosen.slice(data.free_optional_count);
    extras.forEach(code=>{ const input=document.querySelector(`[data-combo-opt='${code}']`); if(input){ input.checked=false; cfg.optionalSelected.delete(code);} });
  }

  function updateConfigPrice(){
    if(!cfg.data) return;
    const data=cfg.data; const noteEl=document.getElementById('cfg-price-note');
    // Base price used for basket line (excludes add-ons; add-ons are attached as priced topping lines)
    let base = data.price_gross;
    let variantObj = null;
    if(cfg.currentVariant){ variantObj = (data.variants||[]).find(v=>v.code==cfg.currentVariant); if(variantObj) base=variantObj.price_gross; }
    let mealApplied = false;
    const mealPriceSpan = document.getElementById('cfg-meal-price');
    let mealCandidate = 0;
    if(cfg.meal){
      // We only apply meal pricing once fries & drink are both selected.
      const haveFries = cfg.fries !== null && cfg.fries !== undefined;
      const haveDrink = cfg.drink !== null && cfg.drink !== undefined;
      if(haveFries && haveDrink){
        // Helper to pick correct price (discounted component price if provided else standard).
        const chosenBurgerStd = variantObj? variantObj.price_gross : data.price_gross;
        const chosenBurgerMeal = variantObj? (variantObj.discounted_price_gross||0) : (data.discounted_price_gross||0);
        // Find fries & drink product objects from meal_components lists.
  const friesList = (data.meal_components?.fries||[]);
  const baseFriesObj = friesList.find(f=> f.code==cfg.fries);
  const sizeup = cfg.sizeup || 'none';
  // If sizeup affects fries (both or fries), pick the fries entry with the highest price (robust to naming)
  const friesObj = (sizeup==='both' || sizeup==='fries') ? (friesList.slice().sort((a,b)=> (b.price_gross||0)-(a.price_gross||0))[0] || baseFriesObj) : baseFriesObj;
        // Drinks: if Go Large, use the T_DRINK_CD of selected drink (product code of large); else use selected regular
        const allDrinks = (data.meal_components?.drinks||[]);
        const regularDrinkObj = allDrinks.find(d=> d.code==cfg.drink);
        let drinkObj = regularDrinkObj;
        if((sizeup==='both' || sizeup==='drink') && regularDrinkObj){
          const largeCode = regularDrinkObj.T_DRINK_CD || regularDrinkObj.t_drink_cd || 0;
          if(largeCode){
            const largeObj = allDrinks.find(d=> d.code==largeCode);
            if(largeObj) drinkObj = largeObj;
          }
        }
        const friesStd = friesObj? friesObj.price_gross : 0;
        const drinkStd = drinkObj? drinkObj.price_gross : 0;
        const friesMeal = friesObj? (friesObj.discounted_price_gross||0) : 0;
        const drinkMeal = drinkObj? (drinkObj.discounted_price_gross||0) : 0;
        // If any discounted component price is zero/absent fall back to its standard price.
        const burgerComponent = (chosenBurgerMeal>0? chosenBurgerMeal : chosenBurgerStd);
        const friesComponent = (friesMeal>0? friesMeal : friesStd);
        const drinkComponent = (drinkMeal>0? drinkMeal : drinkStd);
        mealCandidate = burgerComponent + friesComponent + drinkComponent;
        base = mealCandidate; // effective base becomes sum of discounted components
        mealApplied = true;
        // Savings vs paying individually (all standard or variant standard)
        const singlesTotal = chosenBurgerStd + friesStd + drinkStd;
        const savings = singlesTotal - mealCandidate;
        // noteEl.textContent = savings>0 ? `Meal price applied (save Â£${(savings/100).toFixed(2)})` : 'Meal price applied';
      } else {
        // noteEl.textContent = 'Select fries & drink to apply meal price';
      }
    } else {
      // noteEl.textContent='';
    }
    // Combo optional pricing retained; product options feature removed.
    // Combo optional pricing disabled
    // if(data.type==='combo'){
    //   const chosen = (data.optional||[]).filter(o=>cfg.optionalSelected.has(o.code));
    //   chosen.forEach(o=>{ base += (o.price_gross||0); });
    // }
    // Compute display total including add-ons for user feedback
    let addonsTotal = 0;
    if(data.type==='product' && cfg.addonsSelected && cfg.addonsSelected.size){
      (data.addons||[]).forEach(a=>{ if(cfg.addonsSelected.has(a.code)){ addonsTotal += (a.price_gross||0); } });
    }
    cfg.effectivePrice = base; // used for basket line price
    document.getElementById('cfg-price-main').textContent = money(base + addonsTotal);
    // Show potential meal candidate + savings if applicable
    if(cfg.meal){
      if(mealApplied){
        const chosenBurgerStd = variantObj? variantObj.price_gross : data.price_gross;
        const friesObj = (data.meal_components?.fries||[]).find(f=> f.code==cfg.fries);
        const drinkObj = (data.meal_components?.drinks||[]).find(d=> d.code==cfg.drink);
        const singlesTotal = (chosenBurgerStd||0) + (friesObj?.price_gross||0) + (drinkObj?.price_gross||0);
        const savings = singlesTotal - mealCandidate;
        mealPriceSpan.textContent = `(Meal Â£${(mealCandidate/100).toFixed(2)}${savings>0? ' save Â£'+(savings/100).toFixed(2):''})`;
      } else if(mealCandidate>0){
        mealPriceSpan.textContent = `(Meal Â£${(mealCandidate/100).toFixed(2)} pending)`;
      } else {
        mealPriceSpan.textContent='';
      }
    } else {
      mealPriceSpan.textContent='';
    }
    // Gate Add button
    const addBtn = document.getElementById('cfg-add-btn');
    // Require free choices selection (if any groups exist) before enabling Add
    const freeGroupsContainer = document.getElementById('cfg-free-choices-groups');
    let freeOk = true;
    if(freeGroupsContainer){
      // Collect unique group ids from free choice buttons
      const groups = Array.from(freeGroupsContainer.querySelectorAll('[data-free-choice-group]'))
        .reduce((acc, btn)=>{ const gid = btn.getAttribute('data-free-choice-group'); if(gid && !acc.includes(gid)) acc.push(gid); return acc; }, []);
      if(groups.length > 0){
        for(const gid of groups){
          const any = freeGroupsContainer.querySelector(`[data-free-choice-group='${gid}'].active`);
          if(!any){ freeOk = false; break; }
        }
      }
    }
    // Build reason list for disabled state
    const reasons = [];
    if(cfg.meal){
      if(cfg.fries === null || cfg.fries === undefined) reasons.push('Select fries');
      if(cfg.drink === null || cfg.drink === undefined) reasons.push('Select drink');
    }
    if(!freeOk) reasons.push('Choose free item');
    if(cfg.meal){
      const ready = mealApplied && freeOk; // require fries & drink and free choices
      addBtn.disabled = !ready;
    } else {
      addBtn.disabled = !freeOk;
    }
    const hintEl = document.getElementById('cfg-add-hint');
    if(hintEl){
      if(addBtn.disabled && reasons.length){
        hintEl.textContent = reasons.join(' Â· ');
        hintEl.classList.remove('d-none');
      } else {
        hintEl.textContent='';
        hintEl.classList.add('d-none');
      }
    }
  }

  document.getElementById('cfg-add-btn').addEventListener('click', ()=>{
    if(!cfg.data) return;
    // Build display-friendly choice labels
    const displayChoices = [];
    const baseData = cfg.data;
    // Compute effective fries/drink codes based on Go Large state
    let effectiveFries = cfg.fries;
    let effectiveDrink = cfg.drink;
    const sizeup = cfg.sizeup || 'none';
    if(cfg.meal){
      const friesList = (baseData.meal_components?.fries||[]);
      if(sizeup==='both' || sizeup==='fries'){
        const baseFriesObj = friesList.find(f=> f.code==cfg.fries);
        const largeFriesObj = friesList.find(f=> /large/i.test(String(f.name||'')));
        effectiveFries = (largeFriesObj?.code) || (baseFriesObj?.code) || cfg.fries;
      }
      const drinksList = (baseData.meal_components?.drinks||[]);
      const selDrink = drinksList.find(d=> d.code==cfg.drink);
      if((sizeup==='both' || sizeup==='drink') && selDrink){
        const largeCode = selDrink.T_DRINK_CD || selDrink.t_drink_cd || 0;
        if(largeCode) effectiveDrink = largeCode;
      }
    }
    if(cfg.meal){
      if(effectiveFries){
        const friesObj = (baseData.meal_components?.fries||[]).find(f=> f.code==effectiveFries);
  displayChoices.push(`${friesObj ? friesObj.name : '#'+cfg.fries}`);
      }
      if(effectiveDrink){
        const drinkObj = (baseData.meal_components?.drinks||[]).find(d=> d.code==effectiveDrink);
  displayChoices.push(`${drinkObj ? drinkObj.name : '#'+cfg.drink}`);
      }
    }
    // Combo optional choices display disabled
    // if(baseData.type==='combo'){
    //   (baseData.optional||[]).forEach(o=>{ if(cfg.optionalSelected.has(o.code)) displayChoices.push(`${o.name} ${money(o.price_gross||0)}`); });
    // }
    // Free choice groups display capture
    const freeChosen=[]; (baseData.free_choice_groups||[]).forEach((g,gi)=>{
      const active = document.querySelector(`#cfg-free-choices-groups [data-free-choice-group='freegrp-${baseData.code}-${gi}'].active`);
      if(active){
        const c=parseInt(active.dataset.freeChoiceCode,10); if(!isNaN(c)) freeChosen.push(c);
        const optObj=(g.options||[]).find(o=>o.code==c); if(optObj) displayChoices.push(`Free: ${optObj.name}`);
      }
    });
    const meta = {
      options: [],
      fries: cfg.meal? effectiveFries : null,
      drink: cfg.meal? effectiveDrink : null,
      variant_code: cfg.currentVariant || null,
  sizeup: cfg.meal ? (cfg.sizeup || 'none') : 'none',
  display_choices: displayChoices,
  free_choices: freeChosen
    };
    // Determine display name for variant (use variant's own item description if provided by API)
    const vInfo = cfg.currentVariant ? (cfg.data.variants||[]).find(v=>v.code==cfg.currentVariant) : null;
    const displayName = (vInfo && vInfo.name) ? vInfo.name : cfg.data.name;
    addLine({
      code: cfg.currentVariant || cfg.data.code,
      name: displayName,
      variant: null, // avoid appending (double)/(triple); we use the variant's own description instead
      meal: cfg.meal,
      price: cfg.effectivePrice,
      type: cfg.data.type,
      meta: { ...meta, meal_applied: cfg.meal }
    });
    // After adding base line, if user unchecked toppings (Modify tab) create removal topping lines
    try {
      if(cfg.toppings && cfg.toppings.length){
        const removed = cfg.toppings.filter(t=> t.removed);
        if(removed.length){
          const productLine = basket.lines.find(l=> l.signature===lastProductSignature && l.type!=='topping');
          if(productLine){
            ensureToppingGroup(productLine);
            lastProductSignature = productLine.signature;
            const targetSig = productLine.signature;
            removed.forEach(tp=>{
              const name = (tp.menu_desc || tp.desc || '').trim();
              const norm = name.toLowerCase();
              const toppingLine = { code: `TOPPING_${norm.replace(/\s+/g,'_').toUpperCase()}_NO`, name: 'No ' + name, price:0, type:'topping', meta:{ topping: norm, action:'remove', targetSig } };
              addLine(toppingLine);
            });
          }
        }
      }
    } catch(e){ console.warn('Topping removal generation failed', e); }
    // After adding base line, if add-ons selected, attach as extra topping lines with their prices
    try {
      if(cfg.addonsSelected && cfg.addonsSelected.size){
        const productLine = basket.lines.find(l=> l.signature===lastProductSignature && l.type!=='topping');
        if(productLine){
          ensureToppingGroup(productLine);
          lastProductSignature = productLine.signature;
          const targetSig = productLine.signature;
          const selected = new Set(cfg.addonsSelected);
          (cfg.data.addons||[]).forEach(a=>{
            if(selected.has(a.code)){
              const extraLine = { code: a.code, name: a.name, price: a.price_gross||0, type:'topping', meta:{ kind:'extra', targetSig, extra_product_code: a.code } };
              addLine(extraLine);
            }
          });
        }
      }
    } catch(e){ console.warn('Add-ons attachment failed', e); }
    cfgModal.hide();
  });

  // Provide feedback when user attempts to click disabled Add button
  document.addEventListener('click', (e)=>{
    const btn = e.target.closest('#cfg-add-btn');
    if(!btn) return;
    if(btn.disabled){
      const hintEl = document.getElementById('cfg-add-hint');
      if(hintEl && hintEl.textContent){
        // Simple attention pulse
        hintEl.classList.remove('hint-pulse');
        void hintEl.offsetWidth; // reflow
        hintEl.classList.add('hint-pulse');
      }
    }
  });

  // VAT basis buttons handler
  basisButtonsWrap.addEventListener('click', (e)=>{
    const btn = e.target.closest('[data-basis]');
    if(!btn) return;
    vatBasis = btn.getAttribute('data-basis') === 'eat' ? 'eat' : 'take';
    [...basisButtonsWrap.querySelectorAll('[data-basis]')].forEach(b=> b.classList.toggle('active', b===btn));
    renderProducts();
  });
  // Band buttons removed; channel modal controls band now
  const toggleNetEl = document.getElementById('toggle-net');
  if(toggleNetEl){
    toggleNetEl.addEventListener('change', (e)=>{ showNet = e.target.checked; renderProducts(); });
  } else {
    // Ensure showNet stays false when toggle not available (non-superusers)
    showNet = false;
  }

  // Initial channel load (will select first or last used channel and then fetch menu)
  loadChannels();
  // Paid Out flow
  function submitPaidOut(amountPence, notes){
    if(!amountPence || amountPence <= 0){ alert('Enter a valid amount for Paid Out.'); return; }
    // Enforce allowed bands: 1 (Standard) or 5 (Standard (B))
    if(!(String(currentBand)==='1' || String(currentBand)==='5')){
      alert('Please choose the Standard band (1 or 5) to record Paid Out.');
      if(typeof openChannelModal==='function') openChannelModal();
      return;
    }
    const payload = { price_band: String(currentBand), band_co_number: bandCoNumber, amount_pence: parseInt(amountPence,10)||0, notes: (notes||'').slice(0,500) };
    fetch('/api/paid-out', { method:'POST', credentials:'same-origin', headers:{'Content-Type':'application/json','X-CSRFToken':getCsrf()}, body: JSON.stringify(payload) })
      .then(r=>r.json())
      .then(resp=>{
        if(resp && resp.status==='ok'){
          alert('Paid Out recorded: ' + money(payload.amount_pence));
          const notesEl = document.getElementById('paid-out-notes'); if(notesEl) notesEl.value='';
        } else {
          alert('Failed to record Paid Out: ' + (resp && resp.error ? resp.error : 'unknown error'));
        }
      })
      .catch(()=> alert('Network error recording Paid Out'));
  }
  function openPaidOut(){
    // Require channel selection first
    if(!currentBand || !bandCoNumber){ if(typeof openChannelModal==='function') openChannelModal(); return; }
    ensureCashModal();
    cashState.receivedPence = 0;
    // For paid out we always treat VAT basis as Eat-In per spec
    vatBasis = 'eat'; setCashBasisButtons(); updateCashUI(); cashModal.show();
    const okBtn = document.getElementById('cash-ok');
    if(okBtn){
      // One-time handler for this activation
      okBtn.onclick = ()=>{
        // Prompt for notes at submission time (kept out of main UI per spec)
        const notesVal = (prompt('Notes for Paid Out (optional)','')||'').trim();
        const amt = cashState.receivedPence||0;
        cashModal.hide();
        submitPaidOut(amt, notesVal);
      };
    }
  }
  // Channel selection modal logic
  const channelBtn = document.getElementById('band-channel-btn');
  function openChannelModal(){
    let modalEl = document.getElementById('bandChannelModal');
    if(!modalEl){
      modalEl = document.createElement('div');
      modalEl.className='modal fade';
      modalEl.id='bandChannelModal';
      modalEl.tabIndex='-1';
      modalEl.innerHTML = `\n<div class="modal-dialog modal-lg modal-dialog-scrollable">\n  <div class="modal-content">\n    <div class="modal-header"><h5 class="modal-title">Choose Channel / Price Band</h5><button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button></div>\n    <div class="modal-body" id="band-channel-body"></div>\n    <div class="modal-footer"><button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button></div>\n  </div>\n</div>`;
      document.body.appendChild(modalEl);
    }
    const body = modalEl.querySelector('#band-channel-body');
    if(body){
      const grouped = CHANNEL_ENTRIES.reduce((acc,e)=>{ (acc[e.band]=acc[e.band]||[]).push(e); return acc; },{});
      const bands = Object.keys(grouped).map(n=>parseInt(n,10)).sort((a,b)=>a-b);
      body.innerHTML = bands.map(b=>{
        const rows = grouped[b].map(e=>`<button type='button' class='list-group-item list-group-item-action d-flex justify-content-between align-items-center' data-channel-band='${e.band}' data-channel-co='${e.co}' data-channel-code='${e.code}'>
          <span class='text-start'><strong>${e.desc}</strong><br><small class='text-muted'>Code: ${e.code} / CO: ${e.co}</small></span>
          <span class='badge bg-primary'>Band ${e.band}</span>
        </button>`).join('');
        return `<div class='mb-4'><h6 class='fw-bold'>Band ${b}</h6><div class='list-group'>${rows}</div></div>`;
      }).join('');
    }
    if(window.bootstrap) bootstrap.Modal.getOrCreateInstance(modalEl).show();
    // Avoid attaching duplicate listeners if modal is reopened
    if(!modalEl.dataset.listenerAdded){
      modalEl.addEventListener('click', channelSelectHandler, { once:false });
      modalEl.dataset.listenerAdded = '1';
    }
  }
  function channelSelectHandler(e){
    const btn = e.target.closest('[data-channel-band]');
    if(!btn) return;
    const selectedBand = String(btn.getAttribute('data-channel-band'));
    const selectedCo = btn.getAttribute('data-channel-co') || '';
    const selectedCode = btn.getAttribute('data-channel-code') || '';
    const activeBadge = document.getElementById('band-channel-active');
    if(activeBadge){ activeBadge.textContent = btn.querySelector('strong').textContent + ' ('+selectedCo+')'; activeBadge.classList.remove('d-none'); }
    activeCategoryId = null;
    // apply selection (sets isThirdPartyDelivery and prefetches hot drinks), then fetch menu
    applyChannelSelection(selectedBand, selectedCo, btn.querySelector('strong').textContent, true, selectedCode);
    const modalEl = document.getElementById('bandChannelModal');
    if(window.bootstrap){ const inst = bootstrap.Modal.getInstance(modalEl); if(inst) inst.hide(); }
  }
  if(channelBtn){ channelBtn.addEventListener('click', openChannelModal); }
  // Do not auto-open the modal here; loadChannels() will open it once channel data arrives.
  // This avoids E2E clicks being intercepted by the modal backdrop and keeps tests deterministic.

  // Accessibility: improve modal focus/inert handling to prevent aria-hidden warnings.
  (function manageModalA11y(){
    const modalIds = ['itemConfigModal','checkoutModal'];
    const focusSentinel = document.getElementById('focus-sentinel');
    modalIds.forEach(id => {
      const el = document.getElementById(id);
      if(!el) return;
      // Ensure we control aria-hidden purely via Bootstrap; remove any stale attributes.
      el.removeAttribute('aria-hidden');
      let prevFocused = null;
      el.addEventListener('show.bs.modal', () => {
        el.removeAttribute('inert');
        prevFocused = (document.activeElement instanceof HTMLElement) ? document.activeElement : null;
      });
      el.addEventListener('hide.bs.modal', (ev) => {
        // If a descendant still has focus, move focus out before Bootstrap toggles aria-hidden.
        const active = document.activeElement;
        if(active && el.contains(active)){
          // Prefer sentinel for deterministic off-modal focus; fall back to body if unavailable.
            if(focusSentinel){
              try { focusSentinel.removeAttribute('aria-hidden'); focusSentinel.tabIndex = -1; focusSentinel.focus({preventScroll:true}); } catch(e){}
            } else {
              try { document.body.focus(); } catch(e){}
            }
        }
      });
      el.addEventListener('hidden.bs.modal', () => {
        el.setAttribute('inert','');
        // Clean up sentinel state
        if(focusSentinel){ focusSentinel.setAttribute('aria-hidden','true'); }
        // Restore previous focus if still present and not inside another open modal
        if(prevFocused && document.contains(prevFocused) && !prevFocused.closest('.modal.show')){
          try { prevFocused.focus({preventScroll:true}); } catch(e){}
        }
      });
      if(getComputedStyle(el).display === 'none'){
        el.setAttribute('inert','');
      }
    });
  })();

  function submitOrder(extra){
    if(!basket.lines.length) return;
    checkoutBtn.disabled = true; checkoutBtn.textContent='Saving...';
    // Separate topping pseudo-lines and real lines
    const toppingLines = basket.lines.filter(l=> l.type === 'topping');
    const coreLinesRaw = basket.lines.filter(l=> l.type !== 'topping');
    if(!coreLinesRaw.length){
      alert('Add a product/combo before saving.');
      checkoutBtn.disabled=false; checkoutBtn.textContent='Checkout';
      return;
    }
    // Group toppings by target signature
    const toppingsBySig = {};
    toppingLines.forEach(t=>{
      const target = t.meta?.targetSig;
      if(!target) return;
      (toppingsBySig[target] ||= []).push(t);
    });
    // Build API lines, merging toppings into meta of their target product
    const apiLines = [];
    coreLinesRaw.forEach(l=>{
      const numeric = parseInt(l.code,10);
      if(Number.isNaN(numeric)) return; // skip invalid
      const meta = {...(l.meta||{})};
      let linePriceGross = l.price || 0; // don't mutate basket state
      const attached = toppingsBySig[l.signature] || [];
      if(attached.length){
        const remove = [], extra = [], displayChoices = meta.display_choices ? [...meta.display_choices] : [];
        const extrasProducts = [];
        let extrasSum = 0;
        attached.forEach(tl=>{
          if(tl.meta?.kind === 'extra'){
            extrasProducts.push({ code: parseInt(tl.code,10) || tl.code, name: tl.name, price_gross: tl.price||0 });
            extrasSum += (tl.price||0);
            displayChoices.push(`Extra: ${tl.name} ${tl.price? '('+money(tl.price)+')':''}`);
            return;
          }
          const top = tl.meta?.topping;
          if(!top) return;
          if(tl.meta?.action==='remove'){ remove.push(top); displayChoices.push('No ' + top); }
          else if(tl.meta?.action==='extra'){ extra.push(top); displayChoices.push('Extra ' + top); }
        });
        if(remove.length) meta.toppings_remove = remove;
        if(extra.length) meta.toppings_extra = extra;
        if(extrasProducts.length) meta.extras_products = extrasProducts;
        if(displayChoices.length) meta.display_choices = displayChoices;
        if(extrasSum){
          // Add extras price to the API line's unit price so qty multiplication applies as expected
          linePriceGross = (linePriceGross||0) + extrasSum;
        }
      }
      apiLines.push({
        code: numeric,
        type: (l.type==='combo') ? 'combo' : 'product',
        name: l.name,
        variant: l.variant,
        meal: !!l.meal,
        qty: l.qty||1,
        price_gross: linePriceGross,
        meta
      });
    });
    if(!apiLines.length){
      alert('No valid product lines to submit.');
      checkoutBtn.disabled=false; checkoutBtn.textContent='Checkout';
      return;
    }
  const payload = { price_band: currentBand, band_co_number: bandCoNumber, vat_basis: vatBasis, show_net: showNet, payment_method: extra?.payment_method || 'Cash', crew_id: extra?.crew_id || '0', lines: apiLines };
  fetch('/api/order/submit', { method:'POST', credentials:'same-origin', headers:{'Content-Type':'application/json','X-CSRFToken':getCsrf()}, body: JSON.stringify(payload) })
      .then(r=>r.json())
      .then(resp=>{
        if(resp.order_id){
          alert('Order Saved #' + resp.order_id);
          basket.lines=[]; renderBasket();
        } else {
          alert('Save failed: ' + (resp.error||'unknown'));
        }
      })
      .catch(()=>alert('Network error saving order'))
      .finally(()=>{ checkoutBtn.disabled=false; checkoutBtn.textContent='Checkout'; });
  }

  function getCsrf(){
    const m = document.cookie.match(/csrftoken=([^;]+)/); return m? m[1]:'';
  }
})();
</script>
{% endblock %}