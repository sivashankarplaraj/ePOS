{% extends 'manage_orders/index.html' %}
{% load static %}
{% block content %}
<h5 class="mt-3">Create Order</h5>
<style>
  .basket-pinned-wrapper{ position:fixed; top:0; right:0; width:380px; max-width:95vw; height:100vh; background:var(--bs-body-bg); border-left:1px solid var(--bs-border-color); z-index:1075; display:flex; flex-direction:column; box-shadow:-2px 0 8px rgba(0,0,0,.15); }
  .basket-pinned-wrapper .offcanvas-header{ border-bottom:1px solid var(--bs-border-color); }
  .basket-pinned-wrapper .offcanvas-body{ flex:1 1 auto; overflow:hidden; }
  .basket-pinned-wrapper .offcanvas-body .flex-grow-1{ overflow:auto; }
  body.basket-pinned #basket-fab{ display:none !important; }
  .basket-line-active{ outline:2px solid var(--bs-primary); outline-offset:2px; border-radius:6px; }
  /* Minimal compact adjustment for product cards */
  .product-grid-tight { --bs-gutter-x:.5rem; --bs-gutter-y:.6rem; }
  .product-card-compact .card-body { padding:.55rem .6rem .6rem; }
  .product-card-compact h6 { font-size:.9rem; margin-bottom:.25rem !important; }
  .product-card-compact .fw-semibold { font-size:.75rem; }
  .product-card-compact .price-line { font-size:.8rem; }
  .product-card-compact .badge { font-size:.55rem; }
  @media (min-width: 992px){ .product-card-compact h6 { font-size:.95rem; } }
  /* Basket change pulse */
  @keyframes basketPulse { 0%{ transform:scale(1); box-shadow:0 0 0 0 var(--bs-primary); } 40%{ transform:scale(1.03); box-shadow:0 0 0 .35rem rgba(var(--bs-primary-rgb), .15); } 100%{ transform:scale(1); box-shadow:0 0 0 0 rgba(var(--bs-primary-rgb), 0); } }
  .basket-pulse { animation:basketPulse 550ms ease-out; }
  @media (prefers-reduced-motion: reduce){ .basket-pulse { animation:none; } }
</style>
<style>
  /* Toppings (Modify tab) redesigned as chip toggles */
  #cfg-toppings-list{display:flex;flex-wrap:wrap;gap:.55rem;}
  .topping-chip{--_pad-x:0.9rem;--_pad-y:.55rem;position:relative;border:1px solid var(--bs-border-color);border-radius:2rem;padding:var(--_pad-y) var(--_pad-x);background:var(--bs-body-bg);font-size:.95rem;line-height:1.1;cursor:pointer;user-select:none;display:inline-flex;align-items:center;gap:.4rem;transition:background-color .15s,border-color .15s,color .15s, box-shadow .15s;}
  .topping-chip:hover{background:var(--bs-tertiary-bg);}
  .topping-chip:focus-visible{outline:2px solid var(--bs-primary);outline-offset:2px;}
  .topping-chip.removed{background:rgba(var(--bs-danger-rgb), .08);border-color:rgba(var(--bs-danger-rgb), .6);color:var(--bs-danger-text,#dc3545);text-decoration:line-through;}
  .topping-chip.removed::after{content:'✕';font-size:.8rem;opacity:.85;}
  .topping-chip[data-pressed="true"]{box-shadow:0 0 0 .12rem rgba(var(--bs-primary-rgb), .35);} /* accessibility state */
  @media (pointer:coarse){
    .topping-chip{--_pad-x:1.05rem;--_pad-y:.75rem;font-size:1.05rem;}
  }
  #cfg-toppings-actions{display:flex;flex-wrap:wrap;gap:.6rem;margin-top:.35rem;margin-bottom:.25rem;}
  #cfg-toppings-actions .btn-sm{font-size:.7rem;letter-spacing:.5px;text-transform:uppercase;}
</style>
<!-- Channel / Band Selector -->
<div class="mb-3">
  <div class="d-flex flex-wrap align-items-center gap-2 mb-1">
    <label class="form-label fw-semibold mb-0">Channel / Price Band</label>
    <button type="button" id="band-channel-btn" class="btn btn-lg btn-outline-primary" aria-label="Choose channel for price band">Choose Channel</button>
    <span id="band-channel-active" class="badge bg-secondary d-none"></span>
  </div>
  <div id="band-channel-hint" class="small text-muted mb-2">Select a channel to load menu & prices.</div>
  <div class="form-check mt-2">
    <input class="form-check-input" type="checkbox" id="toggle-net" />
    <label class="form-check-label" for="toggle-net">Show Net (Ex VAT) Prices</label>
  </div>
  <div class="mt-2">
    <label class="form-label small mb-1">VAT Basis</label>
    <div id="basis-buttons" class="d-flex gap-2 flex-wrap">
      <button type="button" class="btn btn-outline-info btn-lg px-3 py-2 active" data-basis="take">Takeaway</button>
      <button type="button" class="btn btn-outline-info btn-lg px-3 py-2" data-basis="eat">Eat-in</button>
    </div>
  </div>
</div>
<!-- Categories below Price Band (horizontal scroll) -->
<div id="categories-section" class="mb-3">
  <div class="fw-semibold small text-uppercase text-secondary mb-2">Categories</div>
  <div id="category-strip" class="d-flex flex-nowrap overflow-auto gap-3 py-3" style="font-size:1.35rem; -webkit-overflow-scrolling: touch;"></div>
</div>

<!-- Items Pane (full width); basket now floating/offcanvas -->
<div id="order-workspace">
  <div id="items-pane" style="max-height:72vh; overflow:auto;">
    <div class="fw-semibold small text-uppercase text-secondary mb-2">Items</div>
  <div id="items-container" class="row product-grid-tight row-cols-2 row-cols-sm-3 row-cols-lg-4 row-cols-xxl-6"><!-- Items injected via JS --></div>
  </div>
</div>

<!-- Floating Basket Button -->
<button id="basket-fab" type="button" class="btn btn-primary rounded-pill shadow-lg position-fixed d-flex align-items-center gap-2" data-bs-toggle="offcanvas" data-bs-target="#basketOffcanvas" aria-controls="basketOffcanvas" style="bottom:1rem; right:1rem; z-index:1080; padding:.9rem 1.2rem; font-size:1.15rem;">
  <span class="badge text-bg-light text-dark" id="basket-fab-count" style="font-size:.95rem; min-width:2rem;">0</span>
  <span>Basket</span>
  <span id="basket-fab-total" class="fw-semibold">£0.00</span>
</button>

<!-- Basket Offcanvas (overlay) -->
<div class="offcanvas offcanvas-end" tabindex="-1" id="basketOffcanvas" aria-labelledby="basketOffcanvasLabel" data-bs-scroll="true">
  <div class="offcanvas-header">
    <h5 class="offcanvas-title" id="basketOffcanvasLabel">Basket</h5>
    <div class="d-flex align-items-center gap-2">
      <button type="button" class="btn btn-sm btn-outline-secondary" id="basket-pin-toggle" title="Pin basket" aria-label="Pin basket">
        <span data-pin-icon>📌</span>
      </button>
      <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
    </div>
  </div>
  <div class="offcanvas-body d-flex flex-column p-0">
    <div class="p-3 border-bottom">
      <div class="small text-uppercase text-secondary fw-semibold">Current Items</div>
    </div>
    <div class="flex-grow-1 overflow-auto p-3">
      <ul class="list-group" id="basket-list" style="font-size:1.15rem;"></ul>
    </div>
    <div class="border-top p-3">
      <div class="d-flex justify-content-between align-items-center mb-3">
        <span class="fw-semibold">Total</span>
        <span id="basket-total" class="fs-4">£0.00</span>
      </div>
      <div class="d-flex justify-content-end gap-2 flex-wrap">
        <button class="btn btn-outline-secondary btn-lg px-4 py-2" id="clear-basket" disabled>Clear</button>
        <button class="btn btn-primary btn-lg px-4 py-2" id="checkout" disabled data-bs-dismiss="offcanvas">Checkout</button>
      </div>
    </div>
  </div>
</div>
<!-- Checkout Modal -->
<div class="modal fade" id="checkoutModal" tabindex="-1" aria-modal="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header py-3">
        <h5 class="modal-title fs-3 fw-bold">Confirm Checkout</h5>
        <button type="button" class="btn-close btn-lg" style="transform:scale(1.3);" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="mb-3">
          <span class="form-label fw-semibold d-block mb-2" style="font-size:1.1rem;">Payment Method</span>
          <div id="pay-method-buttons" class="d-flex flex-wrap gap-2">
            <button type="button" class="btn btn-outline-primary pay-method-btn active" data-pay-method="Cash">Cash</button>
            <button type="button" class="btn btn-outline-primary pay-method-btn" data-pay-method="Card">Card</button>
            <button type="button" class="btn btn-outline-primary pay-method-btn" data-pay-method="On Account">On Account</button>
            <button type="button" class="btn btn-outline-primary pay-method-btn" data-pay-method="Voucher">Voucher</button>
            <button type="button" class="btn btn-outline-primary pay-method-btn" data-pay-method="Paid Out">Paid Out</button>
            <button type="button" class="btn btn-outline-primary pay-method-btn" data-pay-method="Crew Food">Crew Food</button>
            <button type="button" class="btn btn-outline-primary pay-method-btn" data-pay-method="Waste food">Waste food</button>
          </div>
        </div>
        <div class="mb-2">
          <label class="form-label fw-semibold" for="crew-id" style="font-size:1.1rem;">Crew ID</label>
          <input id="crew-id" class="form-control form-control-lg py-3" style="font-size:1.15rem;" type="text" inputmode="numeric" placeholder="0" value="0" />
          <div id="crew-id-error" class="text-danger small mt-1 d-none">Crew ID is required</div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-lg btn-outline-secondary px-4 py-2" data-bs-dismiss="modal">Cancel</button>
        <button class="btn btn-lg btn-primary px-4 py-2 fw-bold" id="confirm-checkout">Confirm</button>
      </div>
    </div>
  </div>
  </div>
<!-- Focus sentinel (kept early to shift focus away before any modal hide sets aria-hidden) -->
<button type="button" id="focus-sentinel" class="visually-hidden" tabindex="-1" aria-hidden="true">Sentinel</button>
<!-- Item Configuration Modal -->
<div class="modal fade" id="itemConfigModal" tabindex="-1" aria-modal="true">
  <div class="modal-dialog modal-lg modal-dialog-scrollable">
    <div class="modal-content">
      <div class="modal-header py-3">
        <h5 class="modal-title fs-3 fw-bold" id="cfg-title">Configure Item</h5>
        <button type="button" class="btn-close btn-lg" style="transform:scale(1.3);" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div id="cfg-loading" class="text-center py-5">Loading...</div>
        <div id="cfg-body" class="d-none">
          <div class="mb-3">
            <div class="d-flex justify-content-between align-items-start gap-2 flex-wrap">
              <div>
                <strong id="cfg-item-name"></strong>
                <span class="badge bg-secondary ms-2 d-none" id="cfg-item-type">Combo</span>
                <span class="badge bg-info text-dark ms-2 d-none" id="cfg-meal-badge">Meal</span>
              </div>
              <div class="text-end small">
                <div>Band <span id="cfg-band"></span></div>
                <div class="d-flex flex-column">
                  <div>Price: <span id="cfg-price-main"></span><span id="cfg-meal-price" class="ms-2 small text-info"></span></div>
                  <div class="small" id="cfg-price-note"></div>
                </div>
              </div>
            </div>
          </div>
          <!-- Config Tabs: Extras appears only when options/choices exist -->
          <div class="mb-3 d-flex gap-2" id="cfg-tabbar">
            <button type="button" class="btn btn-outline-secondary btn-lg px-3 py-2 active" data-cfg-tab="main">Configure</button>
            <button type="button" class="btn btn-outline-secondary btn-lg px-3 py-2 d-none" id="cfg-extras-tab" data-cfg-tab="extras">Extras</button>
            <button type="button" class="btn btn-outline-secondary btn-lg px-3 py-2 d-none" id="cfg-modify-tab" data-cfg-tab="modify">Modify</button>
          </div>
          <div id="cfg-variants" class="mb-4 d-none">
            <label class="form-label fw-semibold" style="font-size:1.15rem;">Variants</label>
            <div id="cfg-variant-list" class="d-flex flex-wrap gap-3"></div>
          </div>
          <div id="cfg-meal-section" class="border rounded p-3 mb-4 d-none" style="background:var(--bs-tertiary-bg);">
            <div class="form-check form-switch mb-3" style="font-size:1.15rem;">
              <input class="form-check-input" style="width:3rem;height:1.5rem;" type="checkbox" id="cfg-meal-toggle" />
              <label class="form-check-label ms-2" for="cfg-meal-toggle">Convert to Meal</label>
            </div>
            <div id="cfg-meal-components" class="row g-3 d-none">
              <div class="col-md-6 d-none" id="cfg-fries-wrap">
                <label class="form-label fw-semibold" style="font-size:1.05rem;">Fries</label>
                <select id="cfg-fries" class="form-select form-select-lg py-3" style="font-size:1.15rem;"></select>
              </div>
              <div class="col-md-6" id="cfg-drinks-wrap">
                <label class="form-label fw-semibold" style="font-size:1.05rem;">Drink</label>
                <div id="cfg-drink-list" class="d-flex flex-wrap gap-2"></div>
              </div>
            </div>
            <div class="mt-2 d-none" id="cfg-sizeup-wrap" style="font-size:1.05rem;">
              <label class="form-label fw-semibold me-2 mb-2">Size Up</label>
              <div id="cfg-sizeup-group" class="btn-group flex-wrap" role="group" aria-label="Size up">
                <button type="button" class="btn btn-outline-secondary active" data-sizeup="none">None</button>
                <button type="button" class="btn btn-outline-secondary" data-sizeup="both">Both</button>
                <button type="button" class="btn btn-outline-secondary" data-sizeup="drink">Drink only</button>
                <button type="button" class="btn btn-outline-secondary" data-sizeup="fries">Fries only</button>
              </div>
            </div>
          </div>
          <div id="cfg-options" class="mb-4 d-none">
            <label class="form-label fw-semibold" style="font-size:1.15rem;">Optional Products</label>
            <div id="cfg-options-list" class="d-flex flex-column gap-2" style="font-size:1.05rem;"></div>
          </div>
          <div id="cfg-toppings" class="mb-4 d-none">
            <div class="d-flex justify-content-between align-items-center mb-1 flex-wrap gap-2">
              <label class="form-label fw-semibold mb-0" style="font-size:1.15rem;">Modify Toppings</label>
              <div id="cfg-toppings-actions" class="d-none">
                <button type="button" class="btn btn-sm btn-outline-secondary" id="cfg-top-restore">Restore All</button>
                <button type="button" class="btn btn-sm btn-outline-danger" id="cfg-top-remove-all">Remove All</button>
              </div>
            </div>
            <div id="cfg-toppings-list"></div>
            <div id="cfg-toppings-note" class="form-text">Tap to toggle. Strikethrough = will be removed.</div>
          </div>
          <div id="cfg-combo-structure" class="mb-4 d-none">
            <label class="form-label fw-semibold" style="font-size:1.15rem;">Combination Components</label>
            <div class="row g-2">
              <div class="col-md-6">
                <div class="border rounded p-3 h-100" style="font-size:1.05rem;">
                  <div class="fw-semibold mb-2" style="font-size:1.05rem;">Compulsory</div>
                  <ul id="cfg-compulsory" class="mb-0 list-unstyled"></ul>
                </div>
              </div>
              <div class="col-md-6">
                <div class="border rounded p-3 h-100" style="font-size:1.05rem;">
                  <div class="fw-semibold mb-2" style="font-size:1.05rem;">Optional <span class="text-muted" id="cfg-free-optional"></span></div>
                  <div id="cfg-optional" class="d-flex flex-column gap-2"></div>
                </div>
              </div>
            </div>
          </div>
          <!-- Free Choices Section (dynamic, inserted/updated by JS) -->
          <div id="cfg-free-choices" class="mb-4 d-none">
            <label class="form-label fw-semibold" style="font-size:1.15rem;">Free Choices</label>
            <div id="cfg-free-choices-groups" class="d-flex flex-column gap-3"></div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-lg btn-outline-secondary px-4 py-2" data-bs-dismiss="modal">Cancel</button>
        <button class="btn btn-lg btn-primary px-4 py-2 fw-bold" id="cfg-add-btn" disabled>Add to Basket</button>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
(function(){
  // Custom lightweight style injection for topping buttons (touch friendly)
  const styleId='topping-buttons-style';
  if(!document.getElementById(styleId)){
    const st=document.createElement('style'); st.id=styleId; st.textContent = `
      .topping-btn { min-height:70px; font-size:1.15rem; letter-spacing:0.5px; }
      @media (pointer:coarse){ .topping-btn { min-height:80px; font-size:1.25rem; } }
    `; document.head.appendChild(st);
  }
  // Hide floating basket button while any offcanvas is open (Bootstrap adds body.offcanvas-open)
  if(!document.getElementById('basket-fab-hide-style')){
    const st2=document.createElement('style'); st2.id='basket-fab-hide-style';
    st2.textContent = `body.offcanvas-open #basket-fab{display:none !important;}`; // must override Bootstrap .d-flex !important
    document.head.appendChild(st2);
  }
  const bandButtonsWrap = null; // removed band buttons UI
  const basisButtonsWrap = document.getElementById('basis-buttons');
  const categoryStrip = document.getElementById('category-strip');
  const itemsContainer = document.getElementById('items-container');
  const basketList = document.getElementById('basket-list');
  const basketTotal = document.getElementById('basket-total');
  const clearBtn = document.getElementById('clear-basket');
  const checkoutBtn = document.getElementById('checkout');
  const basketFab = document.getElementById('basket-fab');
  const basketFabCount = document.getElementById('basket-fab-count');
  const basketFabTotal = document.getElementById('basket-fab-total');
  const basketOffcanvasEl = document.getElementById('basketOffcanvas');
  if(basketOffcanvasEl){
    basketOffcanvasEl.addEventListener('show.bs.offcanvas', ()=>{ if(basketFab) basketFab.classList.add('d-none'); });
    basketOffcanvasEl.addEventListener('hidden.bs.offcanvas', ()=>{ if(basketFab) basketFab.classList.remove('d-none'); });
  }
  let currentBand = '1';
  let vatBasis = 'take'; // default
  let showNet = false;
  let bandCoNumber = '';
  let isThirdPartyDelivery = false; // from selected channel
  let CHANNEL_ENTRIES = [];
  const HOT_DRINKS_GROUP_ID = 11;
  let hotDrinkCodes = new Set();
  function prefetchHotDrinkCodes(){
    hotDrinkCodes = new Set();
    // fetch once per band selection and return a promise
    return fetch(`/api/menu/category/${HOT_DRINKS_GROUP_ID}/items?band=${currentBand}`)
      .then(r=>r.json())
      .then(data=>{
        const arr = (data.items||[]);
        arr.forEach(it=>{ if(it && typeof it.code === 'number') hotDrinkCodes.add(it.code); });
      })
      .catch(()=>{/* non-blocking */});
  }
  function loadChannels(){
    fetch('/api/channels').then(r=>r.json()).then(data=>{
      CHANNEL_ENTRIES = (data.channels||[]).map(c=>({ band:c.band, desc:c.name, code:c.channel_code, co:c.co_number, third: !!c.is_third_party_delivery }));
      // Do not auto-restore or auto-select. Prompt user every time.
      if(CHANNEL_ENTRIES.length){
        // Show a friendly prompt in the categories strip until selection.
        if(categoryStrip){ categoryStrip.innerHTML = '<div class="text-muted small">Choose a channel to load categories.</div>'; }
        // Open the channel selection modal so user picks explicitly.
        if(typeof openChannelModal === 'function') openChannelModal();
      }
    }).catch(()=>{});
  }

  function applyChannelSelection(band, co, desc, fetch=true, code){
    currentBand = String(band);
    bandCoNumber = co || '';
    const badge = document.getElementById('band-channel-active');
    if(badge){ badge.textContent = `${desc} (${bandCoNumber})`; badge.classList.remove('d-none'); }
    // resolve third-party flag
    const match = CHANNEL_ENTRIES.find(c=> (code? c.code===code : (c.band==band && c.co===co && c.desc===desc)) );
    isThirdPartyDelivery = !!(match && match.third);
    // pre-fetch hot drink codes for filtering (used in meal config and possibly categories)
    const done = prefetchHotDrinkCodes();
    activeCategoryId = null;
    if(fetch){
      // Ensure categories load proceeds; we don't strictly need to wait, but chain for robustness
      Promise.resolve(done).finally(()=> fetchMenu());
    }
  }
  // Lightweight data flow: fetch categories first, then items per selected category.
  let categories = [];
  const catItemsCache = {}; // { [catId]: items[] }
  let currentItems = [];
  let activeCategoryId = null;

  const basket = { lines:[], total:0 };
  // Track the signature of the last added non-topping line so toppings can attach to it
  let lastProductSignature = null;
  // Incrementing counter to create unique topping groups
  let toppingGroupCounter = 1;
  let lastRemovedTopping = null; // last removed topping line for undo
  let undoTimer = null;

  // Modal / config state
  const cfgModalEl = document.getElementById('itemConfigModal');
  let cfgModal = null; const ensureModal=()=>{ if(!cfgModal) cfgModal = new bootstrap.Modal(cfgModalEl); };
  const cfg = { data:null, currentVariant:null, meal:false, fries:null, drink:null, optionalSelected:new Set(), effectivePrice:0, sizeup:'none' };
  cfg.toppings = []; // full list of topping objects {acode, desc, menu_desc}
  cfg.toppingsLoaded = false;
  let cfgTab = 'main';

  function money(pence){ return '£' + (pence/100).toFixed(2); }

  // Deterministic, subtle color accents per item (improves scannability without harming contrast)
  function colorAccentForItem(prod){
    const s = String(prod.code ?? prod.name ?? '');
    let hash = 0;
    for(let i=0;i<s.length;i++){ hash = ((hash << 5) - hash) + s.charCodeAt(i); hash |= 0; }
    const hue = Math.abs(hash) % 360; // stable hue per item
    // Light theme: pastel bg + medium border. Dark theme: translucent tint + lighter border.
    const bgLight = `hsl(${hue}, 85%, 97%)`;
    const borderLight = `hsl(${hue}, 65%, 45%)`;
    const bgDark = `hsla(${hue}, 80%, 60%, 0.08)`;
    const borderDark = `hsl(${hue}, 70%, 60%)`;
    return { bgLight, borderLight, bgDark, borderDark };
  }

  function isDarkTheme(){
    const attr = document.documentElement.getAttribute('data-bs-theme');
    if(attr){ return attr.toLowerCase() === 'dark'; }
    return !!(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches);
  }

  function fetchMenu(){
    // Reset caches when band changes
    categories = [];
    currentItems = [];
    for(const k of Object.keys(catItemsCache)) delete catItemsCache[k];
    itemsContainer.innerHTML='';
    categoryStrip.innerHTML='<div class="text-muted small">Loading...</div>';
    fetch(`/api/menu/categories?band=${currentBand}`)
      .then(r=>r.json())
      .then(data=>{ 
        categories = data.categories || []; 
        // If third-party delivery, exclude Hot Drinks category (group 11)
        if(isThirdPartyDelivery){ categories = categories.filter(c=> String(c.id) !== String(HOT_DRINKS_GROUP_ID)); }
        injectStaticCategories();
        renderCategories(); 
        autoSelectFirst(); 
      })
      .catch(err=>{ console.error('Categories load error', err); categoryStrip.innerHTML='<div class="text-danger small">Failed to load</div>'; });
  }

  // --- Static custom categories (e.g. Toppings) ---
  const TOPPINGS_CAT_ID = '__TOPPINGS__';
  const TOPPINGS = [
    'cheese','lettuce','tomato','onions','garlic','chilli','mayo','ketchup','mustard','dills'
  ];
  function injectStaticCategories(){
    // Append toppings category (avoid duplicates on re-fetch)
    if(!categories.find(c=> c.id===TOPPINGS_CAT_ID)){
      categories.push({ id: TOPPINGS_CAT_ID, name: 'Toppings', item_count: TOPPINGS.length, source_type:'S' });
    }
  }

  function renderCategories(){
    categoryStrip.innerHTML='';
    (categories||[]).forEach(cat=>{
      const btn = document.createElement('button');
      btn.className = 'btn btn-outline-secondary';
      btn.textContent = cat.name + (cat.item_count? ` (${cat.item_count})` : '');
      btn.dataset.catId = cat.id;
      if(cat.id === activeCategoryId) btn.classList.add('active');
      btn.addEventListener('click', ()=>{ selectCategory(cat.id); });
      categoryStrip.appendChild(btn);
    });
  }

  function autoSelectFirst(){
    if(!activeCategoryId && (categories||[]).length){
      selectCategory(categories[0].id);
    } else if(activeCategoryId){
      selectCategory(activeCategoryId);
    }
  }

  function selectCategory(catId){
    activeCategoryId = catId;
    renderCategories();
    itemsContainer.innerHTML = '<div class="text-muted small">Loading items...</div>';
    if(catId === TOPPINGS_CAT_ID){
      renderToppings();
      return;
    }
    if(catItemsCache[catId]){
      currentItems = catItemsCache[catId];
      renderProducts();
      return;
    }
    fetch(`/api/menu/category/${catId}/items?band=${currentBand}`)
      .then(r=>r.json())
      .then(data=>{ currentItems = data.items || []; catItemsCache[catId] = currentItems; renderProducts(); })
      .catch(err=>{ console.error('Items load error', err); itemsContainer.innerHTML='<div class="text-danger small">Failed to load items</div>'; });
  }

  function priceForDisplay(prod){
    if(showNet){ return vatBasis==='eat'? prod.price_net_eat : prod.price_net_take; }
    return prod.price_gross;
  }

  function priceForDiscountDisplay(prod){
    if(showNet){ return vatBasis==='eat'? prod.discounted_price_net_eat : prod.discounted_price_net_take; }
    return prod.discounted_price_gross;
  }

  function renderProducts(){
    itemsContainer.innerHTML='';
    if(!currentItems || currentItems.length===0){ return; }
    currentItems.forEach(prod=>{
    const col = document.createElement('div');
    col.className='col';
  const card = document.createElement('div'); card.className='card h-100 shadow-sm product-card-compact';
  // Apply subtle color accents per item (left border + theme-aware background)
  const acc = colorAccentForItem(prod);
  const dark = isDarkTheme();
  card.style.borderLeft = `6px solid ${dark ? acc.borderDark : acc.borderLight}`;
  card.style.backgroundColor = dark ? acc.bgDark : acc.bgLight;
      // Make card the click target
  card.setAttribute('data-open', String(prod.code));
      card.setAttribute('data-item-type', prod.type);
      card.style.cursor = 'pointer';
      const basePrice = priceForDisplay(prod);
  const priceHtml = `<span class='fs-5 fw-bold'>${money(basePrice)}</span>${showNet? ' <span class=\"text-muted small\">ex VAT</span>':''}`;
  const mealLabel = prod.meal_type === 'kids' ? 'Kids Meal' : 'Meal';
  const mealBadge = prod.meal_flag ? ` <span class='badge bg-info text-dark'>${mealLabel}</span>` : '';
      const discountHtml = prod.has_discount ? ` <span class='badge bg-warning text-dark'>Meal ${money(priceForDiscountDisplay(prod))}</span>` : '';
      let variantsHtml='';
      if(prod.variants && prod.variants.length){
        variantsHtml = `<div class='mt-1 small d-flex flex-wrap gap-1'>` + prod.variants.map(v=>{
          return `<span class='badge text-bg-light' role='button' data-var='${v.code}' data-parent='${prod.code}' data-item-type='product' title='${v.label}'>${v.label}: ${money(v.price_gross)}</span>`; }).join('') + `</div>`;
      }
      card.innerHTML = `<div class=\"card-body d-flex flex-column\">        
        <h6 class=\"card-title text-truncate\" title=\"${prod.name}\">${prod.name}${mealBadge}</h6>
        <div class=\"price-line fw-semibold mb-1\">${priceHtml}${discountHtml} #${prod.code}</div>
        ${variantsHtml}
        <div class=\"mt-auto\"></div>
      </div>`;
      col.appendChild(card); itemsContainer.appendChild(col);
    });
  }

  function renderToppings(){
    itemsContainer.innerHTML='';
    const frag=document.createDocumentFragment();
    TOPPINGS.forEach(name=>{
      const norm = name.toLowerCase();
      const col=document.createElement('div'); col.className='col-6 col-md-4 col-xl-3';
  col.innerHTML = `\n        <div class='card h-100 shadow-sm border-2'>\n          <div class='card-body d-flex flex-column'>\n            <h6 class='card-title mb-3 text-truncate fs-5' title='${name}'>${name.charAt(0).toUpperCase()+name.slice(1)}</h6>\n            <div class='mt-auto d-flex flex-column gap-3'>\n              <button type='button' class='btn btn-outline-danger btn-lg fw-semibold topping-btn' data-topping-action='remove' data-topping='${norm}'>Remove</button>\n              <button type='button' class='btn btn-outline-success btn-lg fw-semibold topping-btn' data-topping-action='extra' data-topping='${norm}'>Extra Portion</button>\n            </div>\n          </div>\n        </div>`;
      frag.appendChild(col);
    });
    itemsContainer.appendChild(frag);
  }

  function findItem(type, code){
    // Search current items first, then any cached category
    for(const it of (currentItems||[])){ if(it.type===type && it.code==code) return it; }
    for(const catId of Object.keys(catItemsCache)){
      const arr = catItemsCache[catId] || [];
      for(const it of arr){ if(it.type===type && it.code==code) return it; }
    }
    return null;
  }

  function addLine(line){
    // For non-topping lines compute a baseSignature (without toppings) used for merging.
    if(line.type !== 'topping'){
      line.baseSignature = createBaseSignature(line);
      // Attempt merge only if there is an existing line with same baseSignature and no toppings yet.
      const existing = basket.lines.find(l=> l.type !== 'topping' && l.baseSignature === line.baseSignature && !lineHasToppings(l));
      if(existing){
        existing.qty = (existing.qty||1) + (line.qty||1);
        lastProductSignature = existing.signature; // keep pointing to the merged line
      } else {
        // New line: assign toppingGroup null initially; signature == baseSignature
        line.toppingGroup = null;
        line.signature = line.baseSignature;
        basket.lines.push({...line, qty: line.qty||1});
        lastProductSignature = line.signature;
      }
    } else {
      // Topping pseudo-line: signature derived from target product signature to keep uniqueness
      line.signature = createLineSignature(line);
      basket.lines.push({...line, qty:1});
    }
    renderBasket();
  }
  function createBaseSignature(line){
    const meta = line.meta || {};
    const opts = (meta.options||[]).slice().sort((a,b)=>a-b).join('-');
    const fries = meta.fries || '';
    const drink = meta.drink || '';
    const variant = line.variant || '';
    return [line.code, variant, line.meal?1:0, fries, drink, opts].join('|');
  }
  function lineHasToppings(prodLine){
    return basket.lines.some(t=> t.type==='topping' && t.meta?.targetSig === prodLine.signature);
  }
  function ensureToppingGroup(prodLine){
    if(prodLine.toppingGroup == null){
      prodLine.toppingGroup = toppingGroupCounter++;
      prodLine.signature = prodLine.baseSignature + '|T' + prodLine.toppingGroup;
    }
    return prodLine.toppingGroup;
  }
  function createLineSignature(line){
    if(line.type === 'topping'){
      const meta = line.meta || {};
      const target = meta.targetSig || 'NONE';
      return [line.code, 'TOPPING', target].join('|');
    }
    // Non-topping lines rely on existing signature
    return line.signature || line.baseSignature;
  }
  function renderBasket(){
    basket.total = basket.lines.reduce((s,l)=> s + (l.price * (l.qty||1)), 0);
    basketList.innerHTML='';
    // Exclude topping pseudo-lines from direct display
    const displayLines = basket.lines.filter(l=> l.type !== 'topping');
    displayLines.forEach((l,idx)=>{
      const li=document.createElement('li');
      li.className='list-group-item';
      li.dataset.lineSig = l.signature;
      if(l.signature === lastProductSignature){ li.classList.add('basket-line-active'); }
      // Build choices/details list
      let details = [];
      const meta = l.meta || {};
      if(meta.display_choices && meta.display_choices.length){
        details = meta.display_choices.map(dc=> `<li>${dc}</li>`);
      } else {
        // Legacy: derive basic details from meta codes if names not stored
        if(meta.fries) details.push(`<li>Fries: #${meta.fries}</li>`);
        if(meta.drink) details.push(`<li>Drink: #${meta.drink}</li>`);
        if(meta.options && meta.options.length){ details.push(`<li>Options: ${meta.options.map(o=>'#'+o).join(', ')}</li>`); }
      }
      const detailsHtml = details.length? `<ul class='small text-muted mb-1 ms-2 list-unstyled'>${details.join('')}</ul>` : '';
      // Attach any toppings referencing this line's signature
      const attachedToppings = basket.lines.filter(t=> t.type==='topping' && t.meta?.targetSig === l.signature);
      let toppingsHtml='';
      if(attachedToppings.length){
        const topsLi = attachedToppings.map(t=>{
          const isExtra = /extra/i.test(t.name);
          const isRemove = /(^|\s)no\s/i.test(t.name);
          const cls = isExtra? 'text-success' : (isRemove? 'text-danger' : 'text-info');
          const idxRef = basket.lines.indexOf(t);
          return `<li class='${cls}' data-topping-line='${idxRef}'>${t.name} <button type='button' class='btn btn-sm btn-link p-0 ms-1 text-decoration-none text-muted' data-remove-topping='${idxRef}' aria-label='Remove topping' title='Remove'>&times;</button></li>`;
        });
        toppingsHtml = `<ul class='small mb-1 ms-2 list-unstyled toppings-list' data-parent-sig='${l.signature}'>${topsLi.join('')}</ul>`;
      }
      const customBadge = attachedToppings.length? " <span class='badge bg-warning text-dark ms-1' style='font-size:0.65rem;'>CUSTOM</span>" : '';
      li.innerHTML = `<div class='d-flex justify-content-between align-items-start gap-2'>
        <div class='flex-grow-1'>
          <div class='basket-line-main' data-select-line='${l.signature}' role='button'>${l.name}${l.variant? ' ('+l.variant+')':''}${l.meal? (l.meal_type==='kids'?' Kids Meal':' Meal'):''}${customBadge}</div>
          ${detailsHtml}
          ${toppingsHtml}
        </div>
        <div class='d-flex align-items-center gap-2'>
          <div class='btn-group btn-group-sm' role='group'>
            <button class='btn btn-outline-secondary' data-dec='${basket.lines.indexOf(l)}'>&minus;</button>
            <span class='px-2'>${l.qty||1}</span>
            <button class='btn btn-outline-secondary' data-inc='${basket.lines.indexOf(l)}'>&plus;</button>
          </div>
          <div class='text-end'>
            <div class='fw-semibold'>${money(l.price * (l.qty||1))}</div>
            <button class='btn btn-outline-danger mt-1 d-inline-flex align-items-center justify-content-center'
                    style='width:40px;height:40px;border-width:2px;'
                    data-del='${basket.lines.indexOf(l)}' title='Remove' aria-label='Remove item'>
              <svg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 16 16' fill='currentColor' aria-hidden='true'>
                <path d='M5.5 5.5a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v7a.5.5 0 0 0 1 0v-7z'/>
                <path fill-rule='evenodd' d='M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2h4.118a1 1 0 0 1 .94.658L6.5 3h3l.442-1.342A1 1 0 0 1 10.882 2H15v1zM4.118 4 4 4v9a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4H4.118zM2.5 3V2h11v1h-11z'/>
              </svg>
            </button>
          </div>
        </div>
      </div>`;
      basketList.appendChild(li);
    });
    basketTotal.textContent = money(basket.total);
    clearBtn.disabled = displayLines.length===0; checkoutBtn.disabled = displayLines.length===0;
    const totalQty = displayLines.reduce((s,l)=> s + (l.qty||1),0);
    if(basketFabCount) basketFabCount.textContent = totalQty;
    if(basketFabTotal) basketFabTotal.textContent = money(basket.total);
    if(basketFab){
      basketFab.classList.toggle('btn-outline-secondary', displayLines.length===0);
      basketFab.disabled = displayLines.length===0;
    }
    // Animate basket changes (FAB + list container pulse)
    const pulse = (el)=>{ if(!el) return; el.classList.remove('basket-pulse'); void el.offsetWidth; el.classList.add('basket-pulse'); setTimeout(()=> el.classList.remove('basket-pulse'), 600); };
    pulse(basketFab);
    pulse(document.getElementById('basketOffcanvas'));
  }
  clearBtn.addEventListener('click', ()=>{ basket.lines=[]; lastProductSignature=null; renderBasket(); });
  // Pin / Unpin basket logic
  const pinToggleBtn = document.getElementById('basket-pin-toggle');
  let basketPinned = false;
  const offcanvasEl = document.getElementById('basketOffcanvas');
  function applyPinState(){
    if(basketPinned){
      document.body.classList.add('basket-pinned');
      offcanvasEl.classList.add('basket-pinned-wrapper','show');
      offcanvasEl.style.visibility='visible';
      offcanvasEl.style.transform='none';
      offcanvasEl.removeAttribute('aria-hidden');
      // Remove existing backdrop & body lock
      document.querySelectorAll('.offcanvas-backdrop').forEach(b=> b.remove());
      document.body.classList.remove('offcanvas-open');
      pinToggleBtn.title='Unpin basket'; pinToggleBtn.setAttribute('aria-label','Unpin basket');
      pinToggleBtn.querySelector('[data-pin-icon]').textContent='📍';
      if(basketFab){ basketFab.classList.add('d-none'); basketFab.style.display='none'; }
    } else {
      document.body.classList.remove('basket-pinned');
      offcanvasEl.classList.remove('basket-pinned-wrapper');
      offcanvasEl.style.transform='';
      pinToggleBtn.title='Pin basket'; pinToggleBtn.setAttribute('aria-label','Pin basket');
      pinToggleBtn.querySelector('[data-pin-icon]').textContent='📌';
      // Hide the offcanvas immediately (user can reopen with FAB)
      offcanvasEl.classList.remove('show');
      offcanvasEl.setAttribute('aria-hidden','true');
      offcanvasEl.style.visibility='';
      if(basketFab){ basketFab.classList.remove('d-none'); basketFab.style.display=''; }
    }
  }
  if(pinToggleBtn){
    pinToggleBtn.addEventListener('click', ()=>{ basketPinned = !basketPinned; applyPinState(); });
  }
  // Prevent Bootstrap auto-dismiss when pinned
  offcanvasEl.addEventListener('hide.bs.offcanvas', (e)=>{ if(basketPinned){ e.preventDefault(); } });
  // Checkout flow opens modal to collect payment method and crew ID
  let checkoutModal = null; const ensureCheckoutModal=()=>{ if(!checkoutModal){ checkoutModal = new bootstrap.Modal(document.getElementById('checkoutModal')); } };
  checkoutBtn.addEventListener('click', ()=>{ if(!basket.lines.length) return; ensureCheckoutModal(); document.getElementById('crew-id-error').classList.add('d-none'); checkoutModal.show(); });
  // Payment method button group (touch friendly)
  document.addEventListener('click', (e)=>{
    const btn = e.target.closest('.pay-method-btn');
    if(btn && btn.closest('#pay-method-buttons')){
      const wrap = document.getElementById('pay-method-buttons');
      wrap.querySelectorAll('.pay-method-btn').forEach(b=> b.classList.remove('active'));
      btn.classList.add('active');
    }
  });
  document.getElementById('confirm-checkout').addEventListener('click', ()=>{
  const activePayBtn = document.querySelector('#pay-method-buttons .pay-method-btn.active');
  const payMethod = activePayBtn ? activePayBtn.getAttribute('data-pay-method') : 'Cash';
    const crewId = (document.getElementById('crew-id').value||'').trim();
    if(crewId===''){
      document.getElementById('crew-id-error').classList.remove('d-none');
      return;
    }
    checkoutModal.hide();
    submitOrder({ payment_method: payMethod, crew_id: crewId });
  });

  itemsContainer.addEventListener('click', (e)=>{
    const toppingBtn = e.target.closest('[data-topping-action]');
    if(toppingBtn){
      const topping = toppingBtn.getAttribute('data-topping');
      const action = toppingBtn.getAttribute('data-topping-action');
      if(topping && action){
        if(!lastProductSignature){
          alert('Add a product before applying toppings.');
          return;
        }
        const isRemove = action==='remove';
        const lineName = (isRemove? 'No ' : 'Extra ') + topping.charAt(0).toUpperCase()+topping.slice(1);
        const targetLine = basket.lines.find(l=> l.signature === lastProductSignature && l.type !== 'topping');
        if(!targetLine){ return; }
        if(targetLine.qty > 1){
          targetLine.qty -= 1;
          const clone = { ...targetLine, qty:1 };
          basket.lines.push(clone);
          lastProductSignature = clone.signature; // operate on clone for toppings
        }
        ensureToppingGroup(targetLine);
        lastProductSignature = targetLine.signature;
        const toppingLine = { code: `TOPPING_${topping.toUpperCase()}_${isRemove? 'NO':'EXTRA'}`, name: lineName, price:0, type:'topping', meta:{ topping, action, targetSig: targetLine.signature } };
        addLine(toppingLine);
      }
      return;
    }
    const variant = e.target.closest('[data-var]');
    if(variant){ openConfig('product', variant.dataset.parent, variant.dataset.var); return; }
    const openCard = e.target.closest('[data-open]');
    if(openCard){
      const type = openCard.getAttribute('data-item-type');
      const code = openCard.getAttribute('data-open');
      const base = findItem(type, code);
      const needsConfig = type==='combo' || (base && ((base.variants&&base.variants.length) || base.meal_flag || (base.options&&base.options.length)));
      if(needsConfig){ openConfig(type, code, null); }
      else if(base){ addLine({ code: base.code, name: base.name, qty:1, price: base.price_gross, type: base.type }); }
      return;
    }
  });

  basketList.addEventListener('click', (e)=>{
    const inc = e.target.closest('[data-inc]');
    if(inc){ const i=parseInt(inc.dataset.inc,10); basket.lines[i].qty++; renderBasket(); return; }
    const dec = e.target.closest('[data-dec]');
    if(dec){ const i=parseInt(dec.dataset.dec,10); basket.lines[i].qty--; if(basket.lines[i].qty<=0) basket.lines.splice(i,1); renderBasket(); return; }
    const del = e.target.closest('[data-del]');
    if(del){ const i=parseInt(del.dataset.del,10); const lineToDelete=basket.lines[i]; if(lineToDelete && lineToDelete.signature){ basket.lines = basket.lines.filter(l=> l!==lineToDelete && !(l.type==='topping' && l.meta?.targetSig===lineToDelete.signature)); } else { basket.lines.splice(i,1);} renderBasket(); return; }
    const removeTopBtn = e.target.closest('[data-remove-topping]');
    if(removeTopBtn){ const idx=parseInt(removeTopBtn.dataset.removeTopping,10); if(!isNaN(idx) && basket.lines[idx] && basket.lines[idx].type==='topping'){ const removed = basket.lines.splice(idx,1)[0]; lastRemovedTopping = removed; maybeRevertCustomizedLine(removed.meta?.targetSig); showUndoToast(); renderBasket(); } return; }
    const selectLine = e.target.closest('[data-select-line]');
    if(selectLine){ lastProductSignature = selectLine.dataset.selectLine; renderBasket(); return; }
  });

  function maybeRevertCustomizedLine(sig){
    if(!sig) return;
    const prod = basket.lines.find(l=> l.signature === sig && l.type !== 'topping');
    if(!prod) return;
    const stillHas = basket.lines.some(t=> t.type==='topping' && t.meta?.targetSig === sig);
    if(!stillHas && prod.toppingGroup != null){
      prod.toppingGroup = null;
      prod.signature = prod.baseSignature;
      const existing = basket.lines.find(l=> l!==prod && l.type!=='topping' && l.signature===prod.baseSignature && !lineHasToppings(l));
      if(existing){ existing.qty += prod.qty; basket.lines = basket.lines.filter(l=> l!==prod); }
    }
  }
  function showUndoToast(){
    clearTimeout(undoTimer);
    let toast = document.getElementById('undo-toast');
    if(!toast){
      toast = document.createElement('div');
      toast.id='undo-toast';
      toast.className='alert alert-secondary shadow-sm d-flex align-items-center gap-3 py-2 px-3';
      Object.assign(toast.style,{position:'fixed',bottom:'1rem',left:'50%',transform:'translateX(-50%)',zIndex:2000});
      toast.innerHTML = `<span class='small flex-grow-1'>Topping removed</span><button type='button' class='btn btn-sm btn-outline-primary' id='undo-btn'>Undo</button>`;
      document.body.appendChild(toast);
    }
    toast.classList.remove('d-none');
    document.getElementById('undo-btn').onclick = ()=>{ if(lastRemovedTopping){ basket.lines.push(lastRemovedTopping); lastRemovedTopping=null; toast.classList.add('d-none'); renderBasket(); } };
    undoTimer = setTimeout(()=>{ if(toast){ toast.classList.add('d-none'); lastRemovedTopping=null; } },5000);
  }

  function openConfig(type, code, preVariant){
    ensureModal();
    cfg.data=null; cfg.currentVariant=preVariant; cfg.meal=false; cfg.fries=null; cfg.drink=null; cfg.optionalSelected.clear();
    document.getElementById('cfg-loading').classList.remove('d-none');
    document.getElementById('cfg-body').classList.add('d-none');
    document.getElementById('cfg-add-btn').disabled=true;
    cfgModal.show();
    fetch(`/api/item/${type}/${code}/detail?band=${currentBand}`)
      .then(r=>r.json())
      .then(d=>{ cfg.data=d.item; populateConfig(); })
      .catch(()=>{ document.getElementById('cfg-loading').textContent='Failed to load'; });
  }

  function populateConfig(){
    const data = cfg.data; if(!data) return;
    document.getElementById('cfg-title').textContent = `Configure #${data.code}`;
    document.getElementById('cfg-item-name').textContent = data.name;
    document.getElementById('cfg-item-type').classList.toggle('d-none', data.type!=='combo');
    const cfgMealBadgeEl = document.getElementById('cfg-meal-badge');
    cfgMealBadgeEl.classList.toggle('d-none', !data.meal_flag);
    if (data.meal_flag) {
      cfgMealBadgeEl.textContent = (data.meal_type === 'kids') ? 'Kids Meal' : 'Meal';
    }
    document.getElementById('cfg-band').textContent = currentBand;
    // Variants
    const vWrap = document.getElementById('cfg-variants');
    const vList = document.getElementById('cfg-variant-list'); vList.innerHTML='';
    if(data.variants && data.variants.length){
      vWrap.classList.remove('d-none');
      data.variants.forEach(v=>{
        const btn=document.createElement('button'); btn.type='button'; btn.className='btn btn-sm btn-outline-secondary';
        btn.textContent = `${v.label} ${money(v.price_gross)}`; btn.dataset.code=v.code;
        if(cfg.currentVariant && cfg.currentVariant==v.code) btn.classList.add('active');
        btn.addEventListener('click',()=>{ cfg.currentVariant=v.code; [...vList.children].forEach(c=>c.classList.remove('active')); btn.classList.add('active'); updateConfigPrice(); });
        vList.appendChild(btn);
      });
    } else vWrap.classList.add('d-none');
    // Meal
  const mealSection = document.getElementById('cfg-meal-section');
    const mealToggle = document.getElementById('cfg-meal-toggle');
    const mealComp = document.getElementById('cfg-meal-components');
  const friesSel = document.getElementById('cfg-fries');
  const drinkList = document.getElementById('cfg-drink-list'); friesSel.innerHTML=''; if(drinkList) drinkList.innerHTML='';
  const sizeUpWrap = document.getElementById('cfg-sizeup-wrap');
  const sizeUpGroup = document.getElementById('cfg-sizeup-group');
  function resetSizeUp(){
    cfg.sizeup = 'none';
    if(sizeUpGroup){
      sizeUpGroup.querySelectorAll('[data-sizeup]').forEach(b=>{
        b.classList.toggle('active', b.getAttribute('data-sizeup')==='none');
      });
    }
  }
    const friesWrap = document.getElementById('cfg-fries-wrap');
    const drinksWrap = document.getElementById('cfg-drinks-wrap');
  if(data.meal_flag && data.meal_components && data.meal_components.fries && data.meal_components.fries.length){
      mealSection.classList.remove('d-none');
    mealToggle.checked=false; mealComp.classList.add('d-none');
    sizeUpWrap.classList.add('d-none');
    resetSizeUp();
      friesWrap.classList.add('d-none');
      // Populate fries (we'll auto-select regular when toggle on)
      const friesList = (data.meal_components.fries||[]);
      friesList.forEach(f=>{ const o=document.createElement('option'); o.value=f.code; o.textContent=`${f.name} ${money(f.price_gross)}`; friesSel.appendChild(o); });
      // Filter drinks: only regular where T_DRINK_CD > 0
      let regularDrinks = (data.meal_components.drinks||[]).filter(d=> (d.T_DRINK_CD||d.t_drink_cd||0) > 0);
      // Exclude hot drinks (EPOS_GROUP=11) for third-party delivery channels
      if(isThirdPartyDelivery && hotDrinkCodes && hotDrinkCodes.size){
        regularDrinks = regularDrinks.filter(d=> !hotDrinkCodes.has(d.code));
      }
      if(regularDrinks.length===0){ regularDrinks = (data.meal_components.drinks||[]); }
      // Render drink buttons (no price)
      if(drinkList){
        drinkList.innerHTML='';
        regularDrinks.forEach(dr=>{
          const b=document.createElement('button'); b.type='button'; b.className='btn btn-outline-info';
          b.textContent = dr.name; b.dataset.code = dr.code; b.dataset.tDrinkCd = dr.T_DRINK_CD || dr.t_drink_cd || 0;
          b.addEventListener('click', ()=>{
            cfg.drink = parseInt(b.dataset.code,10);
            // toggle active state
            [...drinkList.children].forEach(c=> c.classList.remove('active'));
            b.classList.add('active');
            updateConfigPrice();
          });
          drinkList.appendChild(b);
        });
        // If only one drink is available, preselect it
        if(drinkList.children.length === 1){
          const only = drinkList.children[0];
          only.classList.add('active');
          cfg.drink = parseInt(only.getAttribute('data-code')||only.dataset.code,10);
        }
      }
      // Defaults when toggled on: select first regular fries and require a drink choice
  friesSel.selectedIndex = -1; cfg.fries=null; cfg.drink=null;
      mealToggle.onchange=()=>{
        cfg.meal=mealToggle.checked;
        mealComp.classList.toggle('d-none', !cfg.meal);
        sizeUpWrap.classList.toggle('d-none', !cfg.meal);
        if(cfg.meal){
          // Auto-select regular fries (assume first option is Regular)
          resetSizeUp();
          if(friesSel.options.length>0){ friesSel.selectedIndex=0; cfg.fries=parseInt(friesSel.value,10); }
        } else {
          cfg.fries=null; cfg.drink=null; 
          resetSizeUp();
        }
        updateConfigPrice();
      };
    friesSel.onchange=()=>{ cfg.fries=friesSel.value? parseInt(friesSel.value,10):null; updateConfigPrice(); };
  // drink selection handled via buttons above
      if(sizeUpGroup){
        resetSizeUp();
        sizeUpGroup.addEventListener('click', (e)=>{
          const btn = e.target.closest('[data-sizeup]'); if(!btn) return;
          const val = btn.getAttribute('data-sizeup');
          cfg.sizeup = val;
          [...sizeUpGroup.querySelectorAll('[data-sizeup]')].forEach(b=> b.classList.toggle('active', b===btn));
          updateConfigPrice();
        });
      }
  } else mealSection.classList.add('d-none');
    // Product options
    const optWrap = document.getElementById('cfg-options');
    const optList = document.getElementById('cfg-options-list'); optList.innerHTML='';
    const renderProductOptions = ()=>{
      optList.innerHTML='';
      if(data.options && data.options.length){
        optWrap.classList.remove('d-none');
        data.options.forEach(o=>{
          const id=`opt-prod-${o.code}`;
          optList.insertAdjacentHTML('beforeend', `<div class='form-check form-check-inline'><input class='form-check-input' type='checkbox' id='${id}' data-opt-code='${o.code}'><label class='form-check-label small' for='${id}'>${o.name} ${money(o.price_gross||0)}</label></div>`);
        });
      } else {
        optWrap.classList.add('d-none');
      }
    };
    renderProductOptions();
    optList.addEventListener('change', e=>{
      const cb=e.target.closest('[data-opt-code]');
      if(cb){
        const code=parseInt(cb.dataset.optCode,10);
        if(cb.checked) cfg.optionalSelected.add(code); else cfg.optionalSelected.delete(code);
        updateConfigPrice();
      }
    });
    // Free choices (if present)
    const freeChoiceWrap = document.getElementById('cfg-free-choices');
    const freeGroupsContainer = document.getElementById('cfg-free-choices-groups');
    const renderFreeChoices = () => {
      freeGroupsContainer.innerHTML='';
      const groups = data.free_choice_groups || [];
      if(groups.length){
        freeChoiceWrap.classList.remove('d-none');
        groups.forEach((g,gi)=>{
          const groupId = `freegrp-${data.code}-${gi}`;
            const inner = document.createElement('div');
            inner.className='border rounded p-3';
            inner.innerHTML = `<div class='fw-semibold mb-2 small'>Pick 1 free (${g.options.length} options)</div>`;
            const optListDiv=document.createElement('div'); optListDiv.className='d-flex flex-wrap gap-2';
            g.options.forEach(o=>{
              const btn=document.createElement('button');
              btn.type='button'; btn.className='btn btn-outline-success';
              btn.dataset.freeChoiceGroup=groupId; btn.dataset.freeChoiceCode=o.code;
              btn.textContent = o.name;
              btn.addEventListener('click',()=>{
                [...optListDiv.querySelectorAll('[data-free-choice-group]')].forEach(b=> b.classList.remove('active'));
                btn.classList.add('active');
                updateConfigPrice();
              });
              optListDiv.appendChild(btn);
            });
            inner.appendChild(optListDiv);
            freeGroupsContainer.appendChild(inner);
        });
      } else {
        freeChoiceWrap.classList.add('d-none');
      }
    };
    renderFreeChoices();
    // Load toppings (Modify tab) only for products (not combos) when opening config.
    const modifyTabBtn = document.getElementById('cfg-modify-tab');
    const toppingsWrap = document.getElementById('cfg-toppings');
    const toppingsList = document.getElementById('cfg-toppings-list');
    toppingsList.innerHTML='';
    cfg.toppings = []; cfg.toppingsLoaded = false;
    if(data.type==='product'){
      fetch(`/api/product/${data.code}/toppings`)
        .then(r=> r.ok? r.json(): Promise.reject())
        .then(resp=>{
          const tops = resp.toppings || [];
          cfg.toppings = tops.map((t,i)=> ({ ...t, idx:i, removed:false }));
          cfg.toppingsLoaded = true;
          if(cfg.toppings.length){
            modifyTabBtn?.classList.remove('d-none');
            const actionsBar = document.getElementById('cfg-toppings-actions');
            actionsBar?.classList.remove('d-none');
            cfg.toppings.forEach(tp=>{
              const name = (tp.menu_desc || tp.desc || '').trim();
              if(!name) return;
              const chip = document.createElement('button');
              chip.type='button';
              chip.className='topping-chip';
              chip.textContent = name;
              chip.dataset.topIndex = String(tp.idx);
              chip.setAttribute('aria-pressed','false');
              chip.addEventListener('click',()=> toggleChip(chip));
              chip.addEventListener('keydown',(ev)=>{ if(ev.key===' '||ev.key==='Enter'){ ev.preventDefault(); toggleChip(chip);} });
              toppingsList.appendChild(chip);
            });
            // Actions: Remove All / Restore All
            const btnRestore = document.getElementById('cfg-top-restore');
            const btnRemoveAll = document.getElementById('cfg-top-remove-all');
            if(btnRestore){ btnRestore.onclick = ()=>{ cfg.toppings.forEach(tp=> tp.removed=false); refreshChips(); }; }
            if(btnRemoveAll){ btnRemoveAll.onclick = ()=>{ cfg.toppings.forEach(tp=> tp.removed=true); refreshChips(); }; }
          } else modifyTabBtn?.classList.add('d-none');
        })
        .catch(()=>{ modifyTabBtn?.classList.add('d-none'); });
    } else modifyTabBtn?.classList.add('d-none');
    // Fallback: If product options missing in detail payload, fetch via API and render
    if(data.type==='product' && (!data.options || data.options.length===0)){
      fetch(`/api/product/${data.code}/options?band=${currentBand}`)
        .then(r=>r.json())
        .then(resp=>{
          if(resp && Array.isArray(resp.options) && resp.options.length){
            data.options = resp.options.map(o=>({ code:o.code, name:o.name, price_gross:o.price_gross }));
            renderProductOptions();
            const extrasTabBtn = document.getElementById('cfg-extras-tab');
            if(extrasTabBtn){ extrasTabBtn.classList.toggle('d-none', false); }
            syncConfigTabs();
          }
        })
        .catch(()=>{});
    }
    // Combo structure
    const comboStruct = document.getElementById('cfg-combo-structure');
    const compUL = document.getElementById('cfg-compulsory');
    const optDiv = document.getElementById('cfg-optional');
    const freeLbl = document.getElementById('cfg-free-optional'); compUL.innerHTML=''; optDiv.innerHTML='';
    if(data.type==='combo'){
      comboStruct.classList.remove('d-none');
      (data.compulsory||[]).forEach(c=>{ compUL.insertAdjacentHTML('beforeend', `<li>${c.name} ${money(c.price_gross)}</li>`); });
      if(data.optional && data.optional.length){
        // Extras for combos are not free; suppress any '(First N free)' text
        freeLbl.textContent = '';
        data.optional.forEach(o=>{
          const id=`opt-combo-${o.code}`;
          optDiv.insertAdjacentHTML('beforeend', `<div class='form-check'><input class='form-check-input' type='checkbox' id='${id}' data-combo-opt='${o.code}'><label class='form-check-label small' for='${id}'>${o.name} ${money(o.price_gross)}</label></div>`);
        });
        optDiv.addEventListener('change', e=>{ const cb=e.target.closest('[data-combo-opt]'); if(cb){ const code=parseInt(cb.dataset.comboOpt,10); if(cb.checked) cfg.optionalSelected.add(code); else cfg.optionalSelected.delete(code); updateConfigPrice(); }});
      }
    } else comboStruct.classList.add('d-none');

    // Extras tab visibility (show when product choices or combo optionals exist)
    const extrasTabBtn = document.getElementById('cfg-extras-tab');
    const hasExtras = (data.options && data.options.length) || (data.type==='combo' && data.optional && data.optional.length);
    if(extrasTabBtn){
      extrasTabBtn.classList.toggle('d-none', !hasExtras);
    }
    cfgTab = 'main';
    syncConfigTabs();
    updateConfigPrice();
    document.getElementById('cfg-loading').classList.add('d-none');
    document.getElementById('cfg-body').classList.remove('d-none');
    document.getElementById('cfg-add-btn').disabled=false;

    // Enforce Kids category (EPOS Group 4) as meal-only: auto-toggle and lock
    try {
      const grpId = data.epos_group_id || data.group_id || null;
      const isKidsGroup = String(grpId) === '4' || (data.meal_type === 'kids');
      if(isKidsGroup && !document.getElementById('cfg-body').classList.contains('d-none')){
        if(mealSection && !mealSection.classList.contains('d-none')){
          mealToggle.checked = true; mealToggle.disabled = true; // lock toggle
          // Reveal components and default fries/drink if needed
          mealComp.classList.remove('d-none');
          sizeUpWrap.classList.remove('d-none');
          if(friesSel.options.length>0 && (cfg.fries==null || cfg.fries==undefined)){
            friesSel.selectedIndex = 0; cfg.fries = parseInt(friesSel.value,10);
          }
          if(drinkList && drinkList.children.length){
            // If none active, preselect first
            const active = Array.from(drinkList.children).find(c=> c.classList.contains('active'));
            if(!active){ drinkList.children[0].classList.add('active'); cfg.drink = parseInt(drinkList.children[0].getAttribute('data-code')||drinkList.children[0].dataset.code,10); }
          }
          cfg.meal = true;
          updateConfigPrice();
        }
      } else {
        // Ensure toggle is enabled for non-kids groups
        if(mealToggle) mealToggle.disabled = false;
      }
    } catch(err) { /* non-blocking */ }
  }

  function syncConfigTabs(){
    const tabbar = document.getElementById('cfg-tabbar');
    if(tabbar){
      const btns = tabbar.querySelectorAll('[data-cfg-tab]');
      btns.forEach(b=> b.classList.toggle('active', b.getAttribute('data-cfg-tab')===cfgTab));
    }
    const data = cfg.data; if(!data) return;
    const hasExtras = (data.options && data.options.length) || (data.type==='combo' && data.optional && data.optional.length);
    // Reset default visibility based on data
    const vWrap = document.getElementById('cfg-variants');
    const mealSection = document.getElementById('cfg-meal-section');
    const optWrap = document.getElementById('cfg-options');
    const comboStruct = document.getElementById('cfg-combo-structure');
  const toppingsWrap = document.getElementById('cfg-toppings');
    if(vWrap) vWrap.classList.toggle('d-none', !(data.variants && data.variants.length));
    const mealOkay = data.meal_flag && data.meal_components && data.meal_components.fries && data.meal_components.fries.length;
    if(mealSection) mealSection.classList.toggle('d-none', !mealOkay);
    if(optWrap) optWrap.classList.toggle('d-none', !(data.options && data.options.length));
    if(comboStruct) comboStruct.classList.toggle('d-none', data.type!=='combo');
    // If on Extras tab, focus only on extras lists
    if(hasExtras && cfgTab==='extras'){
      if(vWrap) vWrap.classList.add('d-none');
      if(mealSection) mealSection.classList.add('d-none');
      if(data.type==='combo'){
        // Hide compulsory column but keep optional side visible
        const compUL = document.getElementById('cfg-compulsory');
        const compCol = compUL ? compUL.closest('.col-md-6') : null;
        const optCol = document.getElementById('cfg-optional')?.closest('.col-md-6');
        if(compCol) compCol.classList.add('d-none');
        if(optCol) optCol.classList.remove('d-none');
        if(comboStruct) comboStruct.classList.remove('d-none');
      }
      if(optWrap) optWrap.classList.toggle('d-none', !(data.options && data.options.length));
      // On Extras tab hide product non-extras sections already handled above
    } else {
      // Configure (main) tab: show core sections, hide extras if we have a dedicated Extras tab
      const compUL = document.getElementById('cfg-compulsory');
      const compCol = compUL ? compUL.closest('.col-md-6') : null;
      const optCol = document.getElementById('cfg-optional')?.closest('.col-md-6');
      if(compCol) compCol.classList.remove('d-none');
      if(hasExtras){
        // Hide product options on main
        if(optWrap) optWrap.classList.add('d-none');
        // Hide combo optional column on main, keep compulsory visible
        if(optCol) optCol.classList.add('d-none');
      } else {
        // If no extras, keep default visibility
        if(optWrap) optWrap.classList.toggle('d-none', !(data.options && data.options.length));
        if(optCol) optCol.classList.remove('d-none');
      }
    }
    // Modify tab visibility (already toggled when toppings loaded); show only its section when active
    if(toppingsWrap){
      toppingsWrap.classList.toggle('d-none', cfgTab!=='modify');
      if(cfgTab==='modify'){
        // Hide other sections when in modify view for clarity
        if(vWrap) vWrap.classList.add('d-none');
        if(mealSection) mealSection.classList.add('d-none');
        if(optWrap) optWrap.classList.add('d-none');
        if(comboStruct) comboStruct.classList.add('d-none');
      }
    }
  }
  function toggleChip(chip){
    const idx = parseInt(chip.dataset.topIndex||'-1',10);
    const tp = cfg.toppings.find(t=> t.idx===idx);
    if(!tp) return;
    tp.removed = !tp.removed;
    refreshChip(chip, tp);
  }
  function refreshChips(){
    document.querySelectorAll('#cfg-toppings-list .topping-chip').forEach(ch=>{
      const idx = parseInt(ch.dataset.topIndex||'-1',10);
      const tp = cfg.toppings.find(t=> t.idx===idx);
      if(tp) refreshChip(ch, tp);
    });
  }
  function refreshChip(chip, tp){
    chip.classList.toggle('removed', !!tp.removed);
    chip.setAttribute('aria-pressed', tp.removed? 'true':'false');
  }

  // Tab click handler
  document.addEventListener('click', (e)=>{
    const btn = e.target.closest('#cfg-tabbar [data-cfg-tab]');
    if(!btn) return;
    cfgTab = btn.getAttribute('data-cfg-tab');
    syncConfigTabs();
  });

  function enforceComboFreeLimit(data){
    if(!data.free_optional_count) return;
    const chosen=[...cfg.optionalSelected];
    if(chosen.length<=data.free_optional_count) return;
    const extras=chosen.slice(data.free_optional_count);
    extras.forEach(code=>{ const input=document.querySelector(`[data-combo-opt='${code}']`); if(input){ input.checked=false; cfg.optionalSelected.delete(code);} });
  }

  function updateConfigPrice(){
    if(!cfg.data) return;
    const data=cfg.data; const noteEl=document.getElementById('cfg-price-note');
    let base = data.price_gross;
    let variantObj = null;
    if(cfg.currentVariant){ variantObj = (data.variants||[]).find(v=>v.code==cfg.currentVariant); if(variantObj) base=variantObj.price_gross; }
    let mealApplied = false;
    const mealPriceSpan = document.getElementById('cfg-meal-price');
    let mealCandidate = 0;
    if(cfg.meal){
      // We only apply meal pricing once fries & drink are both selected.
      const haveFries = cfg.fries !== null && cfg.fries !== undefined;
      const haveDrink = cfg.drink !== null && cfg.drink !== undefined;
      if(haveFries && haveDrink){
        // Helper to pick correct price (discounted component price if provided else standard).
        const chosenBurgerStd = variantObj? variantObj.price_gross : data.price_gross;
        const chosenBurgerMeal = variantObj? (variantObj.discounted_price_gross||0) : (data.discounted_price_gross||0);
        // Find fries & drink product objects from meal_components lists.
  const friesList = (data.meal_components?.fries||[]);
  const baseFriesObj = friesList.find(f=> f.code==cfg.fries);
  const sizeup = cfg.sizeup || 'none';
  // If sizeup affects fries (both or fries), pick the fries entry with the highest price (robust to naming)
  const friesObj = (sizeup==='both' || sizeup==='fries') ? (friesList.slice().sort((a,b)=> (b.price_gross||0)-(a.price_gross||0))[0] || baseFriesObj) : baseFriesObj;
        // Drinks: if Go Large, use the T_DRINK_CD of selected drink (product code of large); else use selected regular
        const allDrinks = (data.meal_components?.drinks||[]);
        const regularDrinkObj = allDrinks.find(d=> d.code==cfg.drink);
        let drinkObj = regularDrinkObj;
        if((sizeup==='both' || sizeup==='drink') && regularDrinkObj){
          const largeCode = regularDrinkObj.T_DRINK_CD || regularDrinkObj.t_drink_cd || 0;
          if(largeCode){
            const largeObj = allDrinks.find(d=> d.code==largeCode);
            if(largeObj) drinkObj = largeObj;
          }
        }
        const friesStd = friesObj? friesObj.price_gross : 0;
        const drinkStd = drinkObj? drinkObj.price_gross : 0;
        const friesMeal = friesObj? (friesObj.discounted_price_gross||0) : 0;
        const drinkMeal = drinkObj? (drinkObj.discounted_price_gross||0) : 0;
        // If any discounted component price is zero/absent fall back to its standard price.
        const burgerComponent = (chosenBurgerMeal>0? chosenBurgerMeal : chosenBurgerStd);
        const friesComponent = (friesMeal>0? friesMeal : friesStd);
        const drinkComponent = (drinkMeal>0? drinkMeal : drinkStd);
        mealCandidate = burgerComponent + friesComponent + drinkComponent;
        base = mealCandidate; // effective base becomes sum of discounted components
        mealApplied = true;
        // Savings vs paying individually (all standard or variant standard)
        const singlesTotal = chosenBurgerStd + friesStd + drinkStd;
        const savings = singlesTotal - mealCandidate;
        noteEl.textContent = savings>0 ? `Meal price applied (save £${(savings/100).toFixed(2)})` : 'Meal price applied';
      } else {
        noteEl.textContent = 'Select fries & drink to apply meal price';
      }
    } else {
      noteEl.textContent='';
    }
    // Add option prices (product options always add full price; combo optional add after free allowance)
    if(data.type==='product'){
      (data.options||[]).forEach(o=>{ if(cfg.optionalSelected.has(o.code)){ base += o.price_gross; } });
    } else if(data.type==='combo'){
      const chosen = (data.optional||[]).filter(o=>cfg.optionalSelected.has(o.code));
      // Always charge for selected combo optionals
      chosen.forEach(o=>{ base += (o.price_gross||0); });
    }
    cfg.effectivePrice = base;
    document.getElementById('cfg-price-main').textContent = money(base);
    // Show potential meal candidate + savings if applicable
    if(cfg.meal){
      if(mealApplied){
        const chosenBurgerStd = variantObj? variantObj.price_gross : data.price_gross;
        const friesObj = (data.meal_components?.fries||[]).find(f=> f.code==cfg.fries);
        const drinkObj = (data.meal_components?.drinks||[]).find(d=> d.code==cfg.drink);
        const singlesTotal = (chosenBurgerStd||0) + (friesObj?.price_gross||0) + (drinkObj?.price_gross||0);
        const savings = singlesTotal - mealCandidate;
        mealPriceSpan.textContent = `(Meal £${(mealCandidate/100).toFixed(2)}${savings>0? ' save £'+(savings/100).toFixed(2):''})`;
      } else if(mealCandidate>0){
        mealPriceSpan.textContent = `(Meal £${(mealCandidate/100).toFixed(2)} pending)`;
      } else {
        mealPriceSpan.textContent='';
      }
    } else {
      mealPriceSpan.textContent='';
    }
    // Gate Add button
    const addBtn = document.getElementById('cfg-add-btn');
    if(cfg.meal){
      const ready = mealApplied; // apply rule: require fries & drink so meal applied
      addBtn.disabled = !ready;
    } else {
      addBtn.disabled = false;
    }
  }

  document.getElementById('cfg-add-btn').addEventListener('click', ()=>{
    if(!cfg.data) return;
    // Build display-friendly choice labels
    const displayChoices = [];
    const baseData = cfg.data;
    // Compute effective fries/drink codes based on Go Large state
    let effectiveFries = cfg.fries;
    let effectiveDrink = cfg.drink;
    const sizeup = cfg.sizeup || 'none';
    if(cfg.meal){
      const friesList = (baseData.meal_components?.fries||[]);
      if(sizeup==='both' || sizeup==='fries'){
        const baseFriesObj = friesList.find(f=> f.code==cfg.fries);
        const largeFriesObj = friesList.find(f=> /large/i.test(String(f.name||'')));
        effectiveFries = (largeFriesObj?.code) || (baseFriesObj?.code) || cfg.fries;
      }
      const drinksList = (baseData.meal_components?.drinks||[]);
      const selDrink = drinksList.find(d=> d.code==cfg.drink);
      if((sizeup==='both' || sizeup==='drink') && selDrink){
        const largeCode = selDrink.T_DRINK_CD || selDrink.t_drink_cd || 0;
        if(largeCode) effectiveDrink = largeCode;
      }
    }
    if(cfg.meal){
      if(effectiveFries){
        const friesObj = (baseData.meal_components?.fries||[]).find(f=> f.code==effectiveFries);
        displayChoices.push(`Fries: ${friesObj? friesObj.name : '#'+cfg.fries}`);
      }
      if(effectiveDrink){
        const drinkObj = (baseData.meal_components?.drinks||[]).find(d=> d.code==effectiveDrink);
        displayChoices.push(`Drink: ${drinkObj? drinkObj.name : '#'+cfg.drink}`);
      }
    }
    // Product options
    if(baseData.type==='product'){
      (baseData.options||[]).forEach(o=>{ if(cfg.optionalSelected.has(o.code)) displayChoices.push(`${o.name} ${money(o.price_gross||0)}`); });
    } else if(baseData.type==='combo'){
      (baseData.optional||[]).forEach(o=>{ if(cfg.optionalSelected.has(o.code)) displayChoices.push(`${o.name} ${money(o.price_gross||0)}`); });
    }
    // Free choice groups display capture
    const freeChosen=[]; (baseData.free_choice_groups||[]).forEach((g,gi)=>{
      const active = document.querySelector(`#cfg-free-choices-groups [data-free-choice-group='freegrp-${baseData.code}-${gi}'].active`);
      if(active){
        const c=parseInt(active.dataset.freeChoiceCode,10); if(!isNaN(c)) freeChosen.push(c);
        const optObj=(g.options||[]).find(o=>o.code==c); if(optObj) displayChoices.push(`Free: ${optObj.name}`);
      }
    });
    const meta = {
      options: [...cfg.optionalSelected],
      fries: cfg.meal? effectiveFries : null,
      drink: cfg.meal? effectiveDrink : null,
      variant_code: cfg.currentVariant || null,
  sizeup: cfg.meal ? (cfg.sizeup || 'none') : 'none',
  display_choices: displayChoices,
  free_choices: freeChosen
    };
    addLine({
      code: cfg.currentVariant || cfg.data.code,
      name: cfg.data.name + (cfg.currentVariant? '*':'') + (cfg.meal? ' Meal':''),
      variant: cfg.currentVariant? (cfg.data.variants||[]).find(v=>v.code==cfg.currentVariant)?.label : null,
      meal: cfg.meal,
      price: cfg.effectivePrice,
      type: cfg.data.type,
      meta: { ...meta, meal_applied: cfg.meal }
    });
    // After adding base line, if user unchecked toppings (Modify tab) create removal topping lines
    try {
      if(cfg.toppings && cfg.toppings.length){
        const removed = cfg.toppings.filter(t=> t.removed);
        if(removed.length){
          const productLine = basket.lines.find(l=> l.signature===lastProductSignature && l.type!=='topping');
          if(productLine){
            ensureToppingGroup(productLine);
            lastProductSignature = productLine.signature;
            const targetSig = productLine.signature;
            removed.forEach(tp=>{
              const name = (tp.menu_desc || tp.desc || '').trim();
              const norm = name.toLowerCase();
              const toppingLine = { code: `TOPPING_${norm.replace(/\s+/g,'_').toUpperCase()}_NO`, name: 'No ' + name, price:0, type:'topping', meta:{ topping: norm, action:'remove', targetSig } };
              addLine(toppingLine);
            });
          }
        }
      }
    } catch(e){ console.warn('Topping removal generation failed', e); }
    cfgModal.hide();
  });

  // VAT basis buttons handler
  basisButtonsWrap.addEventListener('click', (e)=>{
    const btn = e.target.closest('[data-basis]');
    if(!btn) return;
    vatBasis = btn.getAttribute('data-basis') === 'eat' ? 'eat' : 'take';
    [...basisButtonsWrap.querySelectorAll('[data-basis]')].forEach(b=> b.classList.toggle('active', b===btn));
    renderProducts();
  });
  // Band buttons removed; channel modal controls band now
  document.getElementById('toggle-net').addEventListener('change', (e)=>{ showNet = e.target.checked; renderProducts(); });

  // Initial channel load (will select first or last used channel and then fetch menu)
  loadChannels();
  // Channel selection modal logic
  const channelBtn = document.getElementById('band-channel-btn');
  function openChannelModal(){
    let modalEl = document.getElementById('bandChannelModal');
    if(!modalEl){
      modalEl = document.createElement('div');
      modalEl.className='modal fade';
      modalEl.id='bandChannelModal';
      modalEl.tabIndex='-1';
      modalEl.innerHTML = `\n<div class="modal-dialog modal-lg modal-dialog-scrollable">\n  <div class="modal-content">\n    <div class="modal-header"><h5 class="modal-title">Choose Channel / Price Band</h5><button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button></div>\n    <div class="modal-body" id="band-channel-body"></div>\n    <div class="modal-footer"><button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button></div>\n  </div>\n</div>`;
      document.body.appendChild(modalEl);
    }
    const body = modalEl.querySelector('#band-channel-body');
    if(body){
      const grouped = CHANNEL_ENTRIES.reduce((acc,e)=>{ (acc[e.band]=acc[e.band]||[]).push(e); return acc; },{});
      const bands = Object.keys(grouped).map(n=>parseInt(n,10)).sort((a,b)=>a-b);
      body.innerHTML = bands.map(b=>{
        const rows = grouped[b].map(e=>`<button type='button' class='list-group-item list-group-item-action d-flex justify-content-between align-items-center' data-channel-band='${e.band}' data-channel-co='${e.co}' data-channel-code='${e.code}'>
          <span class='text-start'><strong>${e.desc}</strong><br><small class='text-muted'>Code: ${e.code} / CO: ${e.co}</small></span>
          <span class='badge bg-primary'>Band ${e.band}</span>
        </button>`).join('');
        return `<div class='mb-4'><h6 class='fw-bold'>Band ${b}</h6><div class='list-group'>${rows}</div></div>`;
      }).join('');
    }
    if(window.bootstrap) bootstrap.Modal.getOrCreateInstance(modalEl).show();
    // Avoid attaching duplicate listeners if modal is reopened
    if(!modalEl.dataset.listenerAdded){
      modalEl.addEventListener('click', channelSelectHandler, { once:false });
      modalEl.dataset.listenerAdded = '1';
    }
  }
  function channelSelectHandler(e){
    const btn = e.target.closest('[data-channel-band]');
    if(!btn) return;
    const selectedBand = String(btn.getAttribute('data-channel-band'));
    const selectedCo = btn.getAttribute('data-channel-co') || '';
    const selectedCode = btn.getAttribute('data-channel-code') || '';
    const activeBadge = document.getElementById('band-channel-active');
    if(activeBadge){ activeBadge.textContent = btn.querySelector('strong').textContent + ' ('+selectedCo+')'; activeBadge.classList.remove('d-none'); }
    activeCategoryId = null;
    // apply selection (sets isThirdPartyDelivery and prefetches hot drinks), then fetch menu
    applyChannelSelection(selectedBand, selectedCo, btn.querySelector('strong').textContent, true, selectedCode);
    const modalEl = document.getElementById('bandChannelModal');
    if(window.bootstrap){ const inst = bootstrap.Modal.getInstance(modalEl); if(inst) inst.hide(); }
  }
  if(channelBtn){ channelBtn.addEventListener('click', openChannelModal); }
  // Always prompt user to choose a channel on page load by opening the modal (loadChannels will also attempt to open it once data arrives)
  // This ensures no implicit default is used.
  // If channels load slightly later, modal will be opened from loadChannels; this call shows it immediately as a cue.
  openChannelModal();

  // Accessibility: improve modal focus/inert handling to prevent aria-hidden warnings.
  (function manageModalA11y(){
    const modalIds = ['itemConfigModal','checkoutModal'];
    const focusSentinel = document.getElementById('focus-sentinel');
    modalIds.forEach(id => {
      const el = document.getElementById(id);
      if(!el) return;
      // Ensure we control aria-hidden purely via Bootstrap; remove any stale attributes.
      el.removeAttribute('aria-hidden');
      let prevFocused = null;
      el.addEventListener('show.bs.modal', () => {
        el.removeAttribute('inert');
        prevFocused = (document.activeElement instanceof HTMLElement) ? document.activeElement : null;
      });
      el.addEventListener('hide.bs.modal', (ev) => {
        // If a descendant still has focus, move focus out before Bootstrap toggles aria-hidden.
        const active = document.activeElement;
        if(active && el.contains(active)){
          // Prefer sentinel for deterministic off-modal focus; fall back to body if unavailable.
            if(focusSentinel){
              try { focusSentinel.removeAttribute('aria-hidden'); focusSentinel.tabIndex = -1; focusSentinel.focus({preventScroll:true}); } catch(e){}
            } else {
              try { document.body.focus(); } catch(e){}
            }
        }
      });
      el.addEventListener('hidden.bs.modal', () => {
        el.setAttribute('inert','');
        // Clean up sentinel state
        if(focusSentinel){ focusSentinel.setAttribute('aria-hidden','true'); }
        // Restore previous focus if still present and not inside another open modal
        if(prevFocused && document.contains(prevFocused) && !prevFocused.closest('.modal.show')){
          try { prevFocused.focus({preventScroll:true}); } catch(e){}
        }
      });
      if(getComputedStyle(el).display === 'none'){
        el.setAttribute('inert','');
      }
    });
  })();

  function submitOrder(extra){
    if(!basket.lines.length) return;
    checkoutBtn.disabled = true; checkoutBtn.textContent='Saving...';
    // Separate topping pseudo-lines and real lines
    const toppingLines = basket.lines.filter(l=> l.type === 'topping');
    const coreLinesRaw = basket.lines.filter(l=> l.type !== 'topping');
    if(!coreLinesRaw.length){
      alert('Add a product/combo before saving.');
      checkoutBtn.disabled=false; checkoutBtn.textContent='Checkout';
      return;
    }
    // Group toppings by target signature
    const toppingsBySig = {};
    toppingLines.forEach(t=>{
      const target = t.meta?.targetSig;
      if(!target) return;
      (toppingsBySig[target] ||= []).push(t);
    });
    // Build API lines, merging toppings into meta of their target product
    const apiLines = [];
    coreLinesRaw.forEach(l=>{
      const numeric = parseInt(l.code,10);
      if(Number.isNaN(numeric)) return; // skip invalid
      const meta = {...(l.meta||{})};
      const attached = toppingsBySig[l.signature] || [];
      if(attached.length){
        const remove = [], extra = [], displayChoices = meta.display_choices ? [...meta.display_choices] : [];
        attached.forEach(tl=>{
          const top = tl.meta?.topping;
            if(!top) return;
          if(tl.meta?.action==='remove'){ remove.push(top); displayChoices.push('No ' + top); }
          else if(tl.meta?.action==='extra'){ extra.push(top); displayChoices.push('Extra ' + top); }
        });
        if(remove.length) meta.toppings_remove = remove;
        if(extra.length) meta.toppings_extra = extra;
        if(displayChoices.length) meta.display_choices = displayChoices;
      }
      apiLines.push({
        code: numeric,
        type: (l.type==='combo') ? 'combo' : 'product',
        name: l.name,
        variant: l.variant,
        meal: !!l.meal,
        qty: l.qty||1,
        price_gross: l.price,
        meta
      });
    });
    if(!apiLines.length){
      alert('No valid product lines to submit.');
      checkoutBtn.disabled=false; checkoutBtn.textContent='Checkout';
      return;
    }
  const payload = { price_band: currentBand, band_co_number: bandCoNumber, vat_basis: vatBasis, show_net: showNet, payment_method: extra?.payment_method || 'Cash', crew_id: extra?.crew_id || '0', lines: apiLines };
  fetch('/api/order/submit', { method:'POST', credentials:'same-origin', headers:{'Content-Type':'application/json','X-CSRFToken':getCsrf()}, body: JSON.stringify(payload) })
      .then(r=>r.json())
      .then(resp=>{
        if(resp.order_id){
          alert('Order Saved #' + resp.order_id);
          basket.lines=[]; renderBasket();
        } else {
          alert('Save failed: ' + (resp.error||'unknown'));
        }
      })
      .catch(()=>alert('Network error saving order'))
      .finally(()=>{ checkoutBtn.disabled=false; checkoutBtn.textContent='Checkout'; });
  }

  function getCsrf(){
    const m = document.cookie.match(/csrftoken=([^;]+)/); return m? m[1]:'';
  }
})();
</script>
{% endblock %}